// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod petfilter {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod rpc {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_DEVICE_STATE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_DEVICE_STATE: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_DEVICE_STATE: [DeviceState; 5] = [
            DeviceState::Idle,
            DeviceState::Sensing,
            DeviceState::Active,
            DeviceState::Purging,
            DeviceState::Error,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct DeviceState(pub i8);
        #[allow(non_upper_case_globals)]
        impl DeviceState {
            pub const Idle: Self = Self(0);
            pub const Sensing: Self = Self(1);
            pub const Active: Self = Self(2);
            pub const Purging: Self = Self(3);
            pub const Error: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Idle,
                Self::Sensing,
                Self::Active,
                Self::Purging,
                Self::Error,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Idle => Some("Idle"),
                    Self::Sensing => Some("Sensing"),
                    Self::Active => Some("Active"),
                    Self::Purging => Some("Purging"),
                    Self::Error => Some("Error"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for DeviceState {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for DeviceState {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for DeviceState {
            type Output = DeviceState;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for DeviceState {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for DeviceState {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for DeviceState {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TLS_MODE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TLS_MODE: i8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TLS_MODE: [TlsMode; 3] =
            [TlsMode::PskOnly, TlsMode::CertOnly, TlsMode::PskAndCert];

        /// TLS authentication mode for the device's RPC listener.
        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TlsMode(pub i8);
        #[allow(non_upper_case_globals)]
        impl TlsMode {
            pub const PskOnly: Self = Self(0);
            pub const CertOnly: Self = Self(1);
            pub const PskAndCert: Self = Self(2);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 2;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::PskOnly, Self::CertOnly, Self::PskAndCert];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::PskOnly => Some("PskOnly"),
                    Self::CertOnly => Some("CertOnly"),
                    Self::PskAndCert => Some("PskAndCert"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TlsMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TlsMode {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for TlsMode {
            type Output = TlsMode;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for TlsMode {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TlsMode {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TlsMode {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_PAYLOAD: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_PAYLOAD: u8 = 31;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_PAYLOAD: [Payload; 32] = [
            Payload::NONE,
            Payload::GetStatusRequest,
            Payload::StartScrubRequest,
            Payload::StopScrubRequest,
            Payload::ClearFaultsRequest,
            Payload::SetConfigRequest,
            Payload::SetScheduleRequest,
            Payload::CancelScheduleRequest,
            Payload::SubscribeTelemetryRequest,
            Payload::UnsubscribeTelemetryRequest,
            Payload::GetDeviceInfoRequest,
            Payload::StatusResponse,
            Payload::DeviceInfoResponse,
            Payload::AckResponse,
            Payload::TelemetryFrame,
            Payload::StateChangeEvent,
            Payload::FaultEvent,
            Payload::AuthChallengeRequest,
            Payload::AuthChallengeResponse,
            Payload::AuthVerifyRequest,
            Payload::AuthVerifyResponse,
            Payload::ProvisionCertRequest,
            Payload::GetCertStatusRequest,
            Payload::CertStatusResponse,
            Payload::OtaBeginRequest,
            Payload::OtaChunkRequest,
            Payload::OtaFinalizeRequest,
            Payload::OtaResponse,
            Payload::OtaProgressEvent,
            Payload::GetDiagnosticsRequest,
            Payload::ClearDiagnosticsRequest,
            Payload::DiagnosticsResponse,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct Payload(pub u8);
        #[allow(non_upper_case_globals)]
        impl Payload {
            pub const NONE: Self = Self(0);
            pub const GetStatusRequest: Self = Self(1);
            pub const StartScrubRequest: Self = Self(2);
            pub const StopScrubRequest: Self = Self(3);
            pub const ClearFaultsRequest: Self = Self(4);
            pub const SetConfigRequest: Self = Self(5);
            pub const SetScheduleRequest: Self = Self(6);
            pub const CancelScheduleRequest: Self = Self(7);
            pub const SubscribeTelemetryRequest: Self = Self(8);
            pub const UnsubscribeTelemetryRequest: Self = Self(9);
            pub const GetDeviceInfoRequest: Self = Self(10);
            pub const StatusResponse: Self = Self(11);
            pub const DeviceInfoResponse: Self = Self(12);
            pub const AckResponse: Self = Self(13);
            pub const TelemetryFrame: Self = Self(14);
            pub const StateChangeEvent: Self = Self(15);
            pub const FaultEvent: Self = Self(16);
            pub const AuthChallengeRequest: Self = Self(17);
            pub const AuthChallengeResponse: Self = Self(18);
            pub const AuthVerifyRequest: Self = Self(19);
            pub const AuthVerifyResponse: Self = Self(20);
            pub const ProvisionCertRequest: Self = Self(21);
            pub const GetCertStatusRequest: Self = Self(22);
            pub const CertStatusResponse: Self = Self(23);
            pub const OtaBeginRequest: Self = Self(24);
            pub const OtaChunkRequest: Self = Self(25);
            pub const OtaFinalizeRequest: Self = Self(26);
            pub const OtaResponse: Self = Self(27);
            pub const OtaProgressEvent: Self = Self(28);
            pub const GetDiagnosticsRequest: Self = Self(29);
            pub const ClearDiagnosticsRequest: Self = Self(30);
            pub const DiagnosticsResponse: Self = Self(31);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 31;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::GetStatusRequest,
                Self::StartScrubRequest,
                Self::StopScrubRequest,
                Self::ClearFaultsRequest,
                Self::SetConfigRequest,
                Self::SetScheduleRequest,
                Self::CancelScheduleRequest,
                Self::SubscribeTelemetryRequest,
                Self::UnsubscribeTelemetryRequest,
                Self::GetDeviceInfoRequest,
                Self::StatusResponse,
                Self::DeviceInfoResponse,
                Self::AckResponse,
                Self::TelemetryFrame,
                Self::StateChangeEvent,
                Self::FaultEvent,
                Self::AuthChallengeRequest,
                Self::AuthChallengeResponse,
                Self::AuthVerifyRequest,
                Self::AuthVerifyResponse,
                Self::ProvisionCertRequest,
                Self::GetCertStatusRequest,
                Self::CertStatusResponse,
                Self::OtaBeginRequest,
                Self::OtaChunkRequest,
                Self::OtaFinalizeRequest,
                Self::OtaResponse,
                Self::OtaProgressEvent,
                Self::GetDiagnosticsRequest,
                Self::ClearDiagnosticsRequest,
                Self::DiagnosticsResponse,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::GetStatusRequest => Some("GetStatusRequest"),
                    Self::StartScrubRequest => Some("StartScrubRequest"),
                    Self::StopScrubRequest => Some("StopScrubRequest"),
                    Self::ClearFaultsRequest => Some("ClearFaultsRequest"),
                    Self::SetConfigRequest => Some("SetConfigRequest"),
                    Self::SetScheduleRequest => Some("SetScheduleRequest"),
                    Self::CancelScheduleRequest => Some("CancelScheduleRequest"),
                    Self::SubscribeTelemetryRequest => Some("SubscribeTelemetryRequest"),
                    Self::UnsubscribeTelemetryRequest => Some("UnsubscribeTelemetryRequest"),
                    Self::GetDeviceInfoRequest => Some("GetDeviceInfoRequest"),
                    Self::StatusResponse => Some("StatusResponse"),
                    Self::DeviceInfoResponse => Some("DeviceInfoResponse"),
                    Self::AckResponse => Some("AckResponse"),
                    Self::TelemetryFrame => Some("TelemetryFrame"),
                    Self::StateChangeEvent => Some("StateChangeEvent"),
                    Self::FaultEvent => Some("FaultEvent"),
                    Self::AuthChallengeRequest => Some("AuthChallengeRequest"),
                    Self::AuthChallengeResponse => Some("AuthChallengeResponse"),
                    Self::AuthVerifyRequest => Some("AuthVerifyRequest"),
                    Self::AuthVerifyResponse => Some("AuthVerifyResponse"),
                    Self::ProvisionCertRequest => Some("ProvisionCertRequest"),
                    Self::GetCertStatusRequest => Some("GetCertStatusRequest"),
                    Self::CertStatusResponse => Some("CertStatusResponse"),
                    Self::OtaBeginRequest => Some("OtaBeginRequest"),
                    Self::OtaChunkRequest => Some("OtaChunkRequest"),
                    Self::OtaFinalizeRequest => Some("OtaFinalizeRequest"),
                    Self::OtaResponse => Some("OtaResponse"),
                    Self::OtaProgressEvent => Some("OtaProgressEvent"),
                    Self::GetDiagnosticsRequest => Some("GetDiagnosticsRequest"),
                    Self::ClearDiagnosticsRequest => Some("ClearDiagnosticsRequest"),
                    Self::DiagnosticsResponse => Some("DiagnosticsResponse"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for Payload {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for Payload {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for Payload {
            type Output = Payload;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for Payload {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for Payload {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Payload {}
        pub struct PayloadUnionTableOffset {}

        pub enum GetStatusRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GetStatusRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GetStatusRequest<'a> {
            type Inner = GetStatusRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GetStatusRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GetStatusRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args GetStatusRequestArgs,
            ) -> flatbuffers::WIPOffset<GetStatusRequest<'bldr>> {
                let mut builder = GetStatusRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for GetStatusRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct GetStatusRequestArgs {}
        impl<'a> Default for GetStatusRequestArgs {
            #[inline]
            fn default() -> Self {
                GetStatusRequestArgs {}
            }
        }

        pub struct GetStatusRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetStatusRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> GetStatusRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                GetStatusRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GetStatusRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GetStatusRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GetStatusRequest");
                ds.finish()
            }
        }
        pub enum StartScrubRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StartScrubRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for StartScrubRequest<'a> {
            type Inner = StartScrubRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> StartScrubRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                StartScrubRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args StartScrubRequestArgs,
            ) -> flatbuffers::WIPOffset<StartScrubRequest<'bldr>> {
                let mut builder = StartScrubRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for StartScrubRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct StartScrubRequestArgs {}
        impl<'a> Default for StartScrubRequestArgs {
            #[inline]
            fn default() -> Self {
                StartScrubRequestArgs {}
            }
        }

        pub struct StartScrubRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StartScrubRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StartScrubRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StartScrubRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<StartScrubRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for StartScrubRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("StartScrubRequest");
                ds.finish()
            }
        }
        pub enum StopScrubRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StopScrubRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for StopScrubRequest<'a> {
            type Inner = StopScrubRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> StopScrubRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                StopScrubRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args StopScrubRequestArgs,
            ) -> flatbuffers::WIPOffset<StopScrubRequest<'bldr>> {
                let mut builder = StopScrubRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for StopScrubRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct StopScrubRequestArgs {}
        impl<'a> Default for StopScrubRequestArgs {
            #[inline]
            fn default() -> Self {
                StopScrubRequestArgs {}
            }
        }

        pub struct StopScrubRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StopScrubRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StopScrubRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StopScrubRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<StopScrubRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for StopScrubRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("StopScrubRequest");
                ds.finish()
            }
        }
        pub enum ClearFaultsRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ClearFaultsRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ClearFaultsRequest<'a> {
            type Inner = ClearFaultsRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ClearFaultsRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ClearFaultsRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args ClearFaultsRequestArgs,
            ) -> flatbuffers::WIPOffset<ClearFaultsRequest<'bldr>> {
                let mut builder = ClearFaultsRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for ClearFaultsRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct ClearFaultsRequestArgs {}
        impl<'a> Default for ClearFaultsRequestArgs {
            #[inline]
            fn default() -> Self {
                ClearFaultsRequestArgs {}
            }
        }

        pub struct ClearFaultsRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ClearFaultsRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ClearFaultsRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ClearFaultsRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ClearFaultsRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ClearFaultsRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ClearFaultsRequest");
                ds.finish()
            }
        }
        pub enum SetConfigRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SetConfigRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SetConfigRequest<'a> {
            type Inner = SetConfigRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> SetConfigRequest<'a> {
            pub const VT_NH3_ACTIVATE_PPM: flatbuffers::VOffsetT = 4;
            pub const VT_NH3_DEACTIVATE_PPM: flatbuffers::VOffsetT = 6;
            pub const VT_PUMP_DUTY_PERCENT: flatbuffers::VOffsetT = 8;
            pub const VT_UVC_DUTY_PERCENT: flatbuffers::VOffsetT = 10;
            pub const VT_PURGE_DURATION_SECS: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SetConfigRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SetConfigRequestArgs,
            ) -> flatbuffers::WIPOffset<SetConfigRequest<'bldr>> {
                let mut builder = SetConfigRequestBuilder::new(_fbb);
                builder.add_nh3_deactivate_ppm(args.nh3_deactivate_ppm);
                builder.add_nh3_activate_ppm(args.nh3_activate_ppm);
                builder.add_purge_duration_secs(args.purge_duration_secs);
                builder.add_uvc_duty_percent(args.uvc_duty_percent);
                builder.add_pump_duty_percent(args.pump_duty_percent);
                builder.finish()
            }

            #[inline]
            pub fn nh3_activate_ppm(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(SetConfigRequest::VT_NH3_ACTIVATE_PPM, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn nh3_deactivate_ppm(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(SetConfigRequest::VT_NH3_DEACTIVATE_PPM, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn pump_duty_percent(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(SetConfigRequest::VT_PUMP_DUTY_PERCENT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn uvc_duty_percent(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(SetConfigRequest::VT_UVC_DUTY_PERCENT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn purge_duration_secs(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(SetConfigRequest::VT_PURGE_DURATION_SECS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SetConfigRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("nh3_activate_ppm", Self::VT_NH3_ACTIVATE_PPM, false)?
                    .visit_field::<f32>("nh3_deactivate_ppm", Self::VT_NH3_DEACTIVATE_PPM, false)?
                    .visit_field::<u8>("pump_duty_percent", Self::VT_PUMP_DUTY_PERCENT, false)?
                    .visit_field::<u8>("uvc_duty_percent", Self::VT_UVC_DUTY_PERCENT, false)?
                    .visit_field::<u16>("purge_duration_secs", Self::VT_PURGE_DURATION_SECS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SetConfigRequestArgs {
            pub nh3_activate_ppm: f32,
            pub nh3_deactivate_ppm: f32,
            pub pump_duty_percent: u8,
            pub uvc_duty_percent: u8,
            pub purge_duration_secs: u16,
        }
        impl<'a> Default for SetConfigRequestArgs {
            #[inline]
            fn default() -> Self {
                SetConfigRequestArgs {
                    nh3_activate_ppm: 0.0,
                    nh3_deactivate_ppm: 0.0,
                    pump_duty_percent: 0,
                    uvc_duty_percent: 0,
                    purge_duration_secs: 0,
                }
            }
        }

        pub struct SetConfigRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetConfigRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_nh3_activate_ppm(&mut self, nh3_activate_ppm: f32) {
                self.fbb_.push_slot::<f32>(
                    SetConfigRequest::VT_NH3_ACTIVATE_PPM,
                    nh3_activate_ppm,
                    0.0,
                );
            }
            #[inline]
            pub fn add_nh3_deactivate_ppm(&mut self, nh3_deactivate_ppm: f32) {
                self.fbb_.push_slot::<f32>(
                    SetConfigRequest::VT_NH3_DEACTIVATE_PPM,
                    nh3_deactivate_ppm,
                    0.0,
                );
            }
            #[inline]
            pub fn add_pump_duty_percent(&mut self, pump_duty_percent: u8) {
                self.fbb_.push_slot::<u8>(
                    SetConfigRequest::VT_PUMP_DUTY_PERCENT,
                    pump_duty_percent,
                    0,
                );
            }
            #[inline]
            pub fn add_uvc_duty_percent(&mut self, uvc_duty_percent: u8) {
                self.fbb_.push_slot::<u8>(
                    SetConfigRequest::VT_UVC_DUTY_PERCENT,
                    uvc_duty_percent,
                    0,
                );
            }
            #[inline]
            pub fn add_purge_duration_secs(&mut self, purge_duration_secs: u16) {
                self.fbb_.push_slot::<u16>(
                    SetConfigRequest::VT_PURGE_DURATION_SECS,
                    purge_duration_secs,
                    0,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SetConfigRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SetConfigRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SetConfigRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SetConfigRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SetConfigRequest");
                ds.field("nh3_activate_ppm", &self.nh3_activate_ppm());
                ds.field("nh3_deactivate_ppm", &self.nh3_deactivate_ppm());
                ds.field("pump_duty_percent", &self.pump_duty_percent());
                ds.field("uvc_duty_percent", &self.uvc_duty_percent());
                ds.field("purge_duration_secs", &self.purge_duration_secs());
                ds.finish()
            }
        }
        pub enum SetScheduleRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SetScheduleRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SetScheduleRequest<'a> {
            type Inner = SetScheduleRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> SetScheduleRequest<'a> {
            pub const VT_INTERVAL_SECS: flatbuffers::VOffsetT = 4;
            pub const VT_DURATION_SECS: flatbuffers::VOffsetT = 6;
            pub const VT_QUIET_START_HOUR: flatbuffers::VOffsetT = 8;
            pub const VT_QUIET_END_HOUR: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SetScheduleRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SetScheduleRequestArgs,
            ) -> flatbuffers::WIPOffset<SetScheduleRequest<'bldr>> {
                let mut builder = SetScheduleRequestBuilder::new(_fbb);
                builder.add_interval_secs(args.interval_secs);
                builder.add_duration_secs(args.duration_secs);
                builder.add_quiet_end_hour(args.quiet_end_hour);
                builder.add_quiet_start_hour(args.quiet_start_hour);
                builder.finish()
            }

            #[inline]
            pub fn interval_secs(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SetScheduleRequest::VT_INTERVAL_SECS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn duration_secs(&self) -> u16 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u16>(SetScheduleRequest::VT_DURATION_SECS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn quiet_start_hour(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(SetScheduleRequest::VT_QUIET_START_HOUR, Some(255))
                        .unwrap()
                }
            }
            #[inline]
            pub fn quiet_end_hour(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(SetScheduleRequest::VT_QUIET_END_HOUR, Some(255))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SetScheduleRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("interval_secs", Self::VT_INTERVAL_SECS, false)?
                    .visit_field::<u16>("duration_secs", Self::VT_DURATION_SECS, false)?
                    .visit_field::<u8>("quiet_start_hour", Self::VT_QUIET_START_HOUR, false)?
                    .visit_field::<u8>("quiet_end_hour", Self::VT_QUIET_END_HOUR, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SetScheduleRequestArgs {
            pub interval_secs: u32,
            pub duration_secs: u16,
            pub quiet_start_hour: u8,
            pub quiet_end_hour: u8,
        }
        impl<'a> Default for SetScheduleRequestArgs {
            #[inline]
            fn default() -> Self {
                SetScheduleRequestArgs {
                    interval_secs: 0,
                    duration_secs: 0,
                    quiet_start_hour: 255,
                    quiet_end_hour: 255,
                }
            }
        }

        pub struct SetScheduleRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetScheduleRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_interval_secs(&mut self, interval_secs: u32) {
                self.fbb_
                    .push_slot::<u32>(SetScheduleRequest::VT_INTERVAL_SECS, interval_secs, 0);
            }
            #[inline]
            pub fn add_duration_secs(&mut self, duration_secs: u16) {
                self.fbb_
                    .push_slot::<u16>(SetScheduleRequest::VT_DURATION_SECS, duration_secs, 0);
            }
            #[inline]
            pub fn add_quiet_start_hour(&mut self, quiet_start_hour: u8) {
                self.fbb_.push_slot::<u8>(
                    SetScheduleRequest::VT_QUIET_START_HOUR,
                    quiet_start_hour,
                    255,
                );
            }
            #[inline]
            pub fn add_quiet_end_hour(&mut self, quiet_end_hour: u8) {
                self.fbb_.push_slot::<u8>(
                    SetScheduleRequest::VT_QUIET_END_HOUR,
                    quiet_end_hour,
                    255,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SetScheduleRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SetScheduleRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SetScheduleRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SetScheduleRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SetScheduleRequest");
                ds.field("interval_secs", &self.interval_secs());
                ds.field("duration_secs", &self.duration_secs());
                ds.field("quiet_start_hour", &self.quiet_start_hour());
                ds.field("quiet_end_hour", &self.quiet_end_hour());
                ds.finish()
            }
        }
        pub enum CancelScheduleRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CancelScheduleRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CancelScheduleRequest<'a> {
            type Inner = CancelScheduleRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> CancelScheduleRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CancelScheduleRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args CancelScheduleRequestArgs,
            ) -> flatbuffers::WIPOffset<CancelScheduleRequest<'bldr>> {
                let mut builder = CancelScheduleRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for CancelScheduleRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct CancelScheduleRequestArgs {}
        impl<'a> Default for CancelScheduleRequestArgs {
            #[inline]
            fn default() -> Self {
                CancelScheduleRequestArgs {}
            }
        }

        pub struct CancelScheduleRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CancelScheduleRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CancelScheduleRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CancelScheduleRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CancelScheduleRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CancelScheduleRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CancelScheduleRequest");
                ds.finish()
            }
        }
        pub enum SubscribeTelemetryRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SubscribeTelemetryRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SubscribeTelemetryRequest<'a> {
            type Inner = SubscribeTelemetryRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> SubscribeTelemetryRequest<'a> {
            pub const VT_INTERVAL_MS: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SubscribeTelemetryRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SubscribeTelemetryRequestArgs,
            ) -> flatbuffers::WIPOffset<SubscribeTelemetryRequest<'bldr>> {
                let mut builder = SubscribeTelemetryRequestBuilder::new(_fbb);
                builder.add_interval_ms(args.interval_ms);
                builder.finish()
            }

            #[inline]
            pub fn interval_ms(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(SubscribeTelemetryRequest::VT_INTERVAL_MS, Some(1000))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SubscribeTelemetryRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("interval_ms", Self::VT_INTERVAL_MS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SubscribeTelemetryRequestArgs {
            pub interval_ms: u32,
        }
        impl<'a> Default for SubscribeTelemetryRequestArgs {
            #[inline]
            fn default() -> Self {
                SubscribeTelemetryRequestArgs { interval_ms: 1000 }
            }
        }

        pub struct SubscribeTelemetryRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SubscribeTelemetryRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_interval_ms(&mut self, interval_ms: u32) {
                self.fbb_.push_slot::<u32>(
                    SubscribeTelemetryRequest::VT_INTERVAL_MS,
                    interval_ms,
                    1000,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SubscribeTelemetryRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SubscribeTelemetryRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SubscribeTelemetryRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SubscribeTelemetryRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SubscribeTelemetryRequest");
                ds.field("interval_ms", &self.interval_ms());
                ds.finish()
            }
        }
        pub enum UnsubscribeTelemetryRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct UnsubscribeTelemetryRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for UnsubscribeTelemetryRequest<'a> {
            type Inner = UnsubscribeTelemetryRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> UnsubscribeTelemetryRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                UnsubscribeTelemetryRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args UnsubscribeTelemetryRequestArgs,
            ) -> flatbuffers::WIPOffset<UnsubscribeTelemetryRequest<'bldr>> {
                let mut builder = UnsubscribeTelemetryRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for UnsubscribeTelemetryRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct UnsubscribeTelemetryRequestArgs {}
        impl<'a> Default for UnsubscribeTelemetryRequestArgs {
            #[inline]
            fn default() -> Self {
                UnsubscribeTelemetryRequestArgs {}
            }
        }

        pub struct UnsubscribeTelemetryRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnsubscribeTelemetryRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> UnsubscribeTelemetryRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                UnsubscribeTelemetryRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<UnsubscribeTelemetryRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for UnsubscribeTelemetryRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("UnsubscribeTelemetryRequest");
                ds.finish()
            }
        }
        pub enum GetDeviceInfoRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GetDeviceInfoRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GetDeviceInfoRequest<'a> {
            type Inner = GetDeviceInfoRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GetDeviceInfoRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GetDeviceInfoRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args GetDeviceInfoRequestArgs,
            ) -> flatbuffers::WIPOffset<GetDeviceInfoRequest<'bldr>> {
                let mut builder = GetDeviceInfoRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for GetDeviceInfoRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct GetDeviceInfoRequestArgs {}
        impl<'a> Default for GetDeviceInfoRequestArgs {
            #[inline]
            fn default() -> Self {
                GetDeviceInfoRequestArgs {}
            }
        }

        pub struct GetDeviceInfoRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetDeviceInfoRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> GetDeviceInfoRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                GetDeviceInfoRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GetDeviceInfoRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GetDeviceInfoRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GetDeviceInfoRequest");
                ds.finish()
            }
        }
        pub enum StatusResponseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StatusResponse<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for StatusResponse<'a> {
            type Inner = StatusResponse<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> StatusResponse<'a> {
            pub const VT_STATE: flatbuffers::VOffsetT = 4;
            pub const VT_NH3_PPM: flatbuffers::VOffsetT = 6;
            pub const VT_NH3_AVG_PPM: flatbuffers::VOffsetT = 8;
            pub const VT_FLOW_ML_PER_MIN: flatbuffers::VOffsetT = 10;
            pub const VT_TEMPERATURE_C: flatbuffers::VOffsetT = 12;
            pub const VT_TANK_A_OK: flatbuffers::VOffsetT = 14;
            pub const VT_TANK_B_OK: flatbuffers::VOffsetT = 16;
            pub const VT_PUMP_DUTY: flatbuffers::VOffsetT = 18;
            pub const VT_UVC_DUTY: flatbuffers::VOffsetT = 20;
            pub const VT_FAULT_FLAGS: flatbuffers::VOffsetT = 22;
            pub const VT_UPTIME_SECS: flatbuffers::VOffsetT = 24;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                StatusResponse { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args StatusResponseArgs,
            ) -> flatbuffers::WIPOffset<StatusResponse<'bldr>> {
                let mut builder = StatusResponseBuilder::new(_fbb);
                builder.add_uptime_secs(args.uptime_secs);
                builder.add_temperature_c(args.temperature_c);
                builder.add_flow_ml_per_min(args.flow_ml_per_min);
                builder.add_nh3_avg_ppm(args.nh3_avg_ppm);
                builder.add_nh3_ppm(args.nh3_ppm);
                builder.add_fault_flags(args.fault_flags);
                builder.add_uvc_duty(args.uvc_duty);
                builder.add_pump_duty(args.pump_duty);
                builder.add_tank_b_ok(args.tank_b_ok);
                builder.add_tank_a_ok(args.tank_a_ok);
                builder.add_state(args.state);
                builder.finish()
            }

            #[inline]
            pub fn state(&self) -> DeviceState {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<DeviceState>(StatusResponse::VT_STATE, Some(DeviceState::Idle))
                        .unwrap()
                }
            }
            #[inline]
            pub fn nh3_ppm(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(StatusResponse::VT_NH3_PPM, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn nh3_avg_ppm(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(StatusResponse::VT_NH3_AVG_PPM, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn flow_ml_per_min(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(StatusResponse::VT_FLOW_ML_PER_MIN, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn temperature_c(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(StatusResponse::VT_TEMPERATURE_C, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn tank_a_ok(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(StatusResponse::VT_TANK_A_OK, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn tank_b_ok(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(StatusResponse::VT_TANK_B_OK, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn pump_duty(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(StatusResponse::VT_PUMP_DUTY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn uvc_duty(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(StatusResponse::VT_UVC_DUTY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn fault_flags(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(StatusResponse::VT_FAULT_FLAGS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn uptime_secs(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(StatusResponse::VT_UPTIME_SECS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for StatusResponse<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<DeviceState>("state", Self::VT_STATE, false)?
                    .visit_field::<f32>("nh3_ppm", Self::VT_NH3_PPM, false)?
                    .visit_field::<f32>("nh3_avg_ppm", Self::VT_NH3_AVG_PPM, false)?
                    .visit_field::<f32>("flow_ml_per_min", Self::VT_FLOW_ML_PER_MIN, false)?
                    .visit_field::<f32>("temperature_c", Self::VT_TEMPERATURE_C, false)?
                    .visit_field::<bool>("tank_a_ok", Self::VT_TANK_A_OK, false)?
                    .visit_field::<bool>("tank_b_ok", Self::VT_TANK_B_OK, false)?
                    .visit_field::<u8>("pump_duty", Self::VT_PUMP_DUTY, false)?
                    .visit_field::<u8>("uvc_duty", Self::VT_UVC_DUTY, false)?
                    .visit_field::<u8>("fault_flags", Self::VT_FAULT_FLAGS, false)?
                    .visit_field::<u64>("uptime_secs", Self::VT_UPTIME_SECS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct StatusResponseArgs {
            pub state: DeviceState,
            pub nh3_ppm: f32,
            pub nh3_avg_ppm: f32,
            pub flow_ml_per_min: f32,
            pub temperature_c: f32,
            pub tank_a_ok: bool,
            pub tank_b_ok: bool,
            pub pump_duty: u8,
            pub uvc_duty: u8,
            pub fault_flags: u8,
            pub uptime_secs: u64,
        }
        impl<'a> Default for StatusResponseArgs {
            #[inline]
            fn default() -> Self {
                StatusResponseArgs {
                    state: DeviceState::Idle,
                    nh3_ppm: 0.0,
                    nh3_avg_ppm: 0.0,
                    flow_ml_per_min: 0.0,
                    temperature_c: 0.0,
                    tank_a_ok: false,
                    tank_b_ok: false,
                    pump_duty: 0,
                    uvc_duty: 0,
                    fault_flags: 0,
                    uptime_secs: 0,
                }
            }
        }

        pub struct StatusResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StatusResponseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_state(&mut self, state: DeviceState) {
                self.fbb_.push_slot::<DeviceState>(
                    StatusResponse::VT_STATE,
                    state,
                    DeviceState::Idle,
                );
            }
            #[inline]
            pub fn add_nh3_ppm(&mut self, nh3_ppm: f32) {
                self.fbb_
                    .push_slot::<f32>(StatusResponse::VT_NH3_PPM, nh3_ppm, 0.0);
            }
            #[inline]
            pub fn add_nh3_avg_ppm(&mut self, nh3_avg_ppm: f32) {
                self.fbb_
                    .push_slot::<f32>(StatusResponse::VT_NH3_AVG_PPM, nh3_avg_ppm, 0.0);
            }
            #[inline]
            pub fn add_flow_ml_per_min(&mut self, flow_ml_per_min: f32) {
                self.fbb_.push_slot::<f32>(
                    StatusResponse::VT_FLOW_ML_PER_MIN,
                    flow_ml_per_min,
                    0.0,
                );
            }
            #[inline]
            pub fn add_temperature_c(&mut self, temperature_c: f32) {
                self.fbb_
                    .push_slot::<f32>(StatusResponse::VT_TEMPERATURE_C, temperature_c, 0.0);
            }
            #[inline]
            pub fn add_tank_a_ok(&mut self, tank_a_ok: bool) {
                self.fbb_
                    .push_slot::<bool>(StatusResponse::VT_TANK_A_OK, tank_a_ok, false);
            }
            #[inline]
            pub fn add_tank_b_ok(&mut self, tank_b_ok: bool) {
                self.fbb_
                    .push_slot::<bool>(StatusResponse::VT_TANK_B_OK, tank_b_ok, false);
            }
            #[inline]
            pub fn add_pump_duty(&mut self, pump_duty: u8) {
                self.fbb_
                    .push_slot::<u8>(StatusResponse::VT_PUMP_DUTY, pump_duty, 0);
            }
            #[inline]
            pub fn add_uvc_duty(&mut self, uvc_duty: u8) {
                self.fbb_
                    .push_slot::<u8>(StatusResponse::VT_UVC_DUTY, uvc_duty, 0);
            }
            #[inline]
            pub fn add_fault_flags(&mut self, fault_flags: u8) {
                self.fbb_
                    .push_slot::<u8>(StatusResponse::VT_FAULT_FLAGS, fault_flags, 0);
            }
            #[inline]
            pub fn add_uptime_secs(&mut self, uptime_secs: u64) {
                self.fbb_
                    .push_slot::<u64>(StatusResponse::VT_UPTIME_SECS, uptime_secs, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StatusResponseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StatusResponseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<StatusResponse<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for StatusResponse<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("StatusResponse");
                ds.field("state", &self.state());
                ds.field("nh3_ppm", &self.nh3_ppm());
                ds.field("nh3_avg_ppm", &self.nh3_avg_ppm());
                ds.field("flow_ml_per_min", &self.flow_ml_per_min());
                ds.field("temperature_c", &self.temperature_c());
                ds.field("tank_a_ok", &self.tank_a_ok());
                ds.field("tank_b_ok", &self.tank_b_ok());
                ds.field("pump_duty", &self.pump_duty());
                ds.field("uvc_duty", &self.uvc_duty());
                ds.field("fault_flags", &self.fault_flags());
                ds.field("uptime_secs", &self.uptime_secs());
                ds.finish()
            }
        }
        pub enum DeviceInfoResponseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DeviceInfoResponse<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DeviceInfoResponse<'a> {
            type Inner = DeviceInfoResponse<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DeviceInfoResponse<'a> {
            pub const VT_FIRMWARE_VERSION: flatbuffers::VOffsetT = 4;
            pub const VT_HARDWARE_REVISION: flatbuffers::VOffsetT = 6;
            pub const VT_SERIAL_NUMBER: flatbuffers::VOffsetT = 8;
            pub const VT_UPTIME_SECS: flatbuffers::VOffsetT = 10;
            pub const VT_CAPABILITIES: flatbuffers::VOffsetT = 12;
            pub const VT_MAX_CLIENTS: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DeviceInfoResponse { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args DeviceInfoResponseArgs<'args>,
            ) -> flatbuffers::WIPOffset<DeviceInfoResponse<'bldr>> {
                let mut builder = DeviceInfoResponseBuilder::new(_fbb);
                builder.add_uptime_secs(args.uptime_secs);
                builder.add_capabilities(args.capabilities);
                if let Some(x) = args.serial_number {
                    builder.add_serial_number(x);
                }
                if let Some(x) = args.hardware_revision {
                    builder.add_hardware_revision(x);
                }
                if let Some(x) = args.firmware_version {
                    builder.add_firmware_version(x);
                }
                builder.add_max_clients(args.max_clients);
                builder.finish()
            }

            #[inline]
            pub fn firmware_version(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        DeviceInfoResponse::VT_FIRMWARE_VERSION,
                        None,
                    )
                }
            }
            #[inline]
            pub fn hardware_revision(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        DeviceInfoResponse::VT_HARDWARE_REVISION,
                        None,
                    )
                }
            }
            #[inline]
            pub fn serial_number(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        DeviceInfoResponse::VT_SERIAL_NUMBER,
                        None,
                    )
                }
            }
            #[inline]
            pub fn uptime_secs(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(DeviceInfoResponse::VT_UPTIME_SECS, Some(0))
                        .unwrap()
                }
            }
            /// Bitmask: bit0=compression, bit1=chunked, bit2=cert_auth, bit3=multi_client
            #[inline]
            pub fn capabilities(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DeviceInfoResponse::VT_CAPABILITIES, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn max_clients(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(DeviceInfoResponse::VT_MAX_CLIENTS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for DeviceInfoResponse<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "firmware_version",
                        Self::VT_FIRMWARE_VERSION,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "hardware_revision",
                        Self::VT_HARDWARE_REVISION,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "serial_number",
                        Self::VT_SERIAL_NUMBER,
                        false,
                    )?
                    .visit_field::<u64>("uptime_secs", Self::VT_UPTIME_SECS, false)?
                    .visit_field::<u32>("capabilities", Self::VT_CAPABILITIES, false)?
                    .visit_field::<u8>("max_clients", Self::VT_MAX_CLIENTS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DeviceInfoResponseArgs<'a> {
            pub firmware_version: Option<flatbuffers::WIPOffset<&'a str>>,
            pub hardware_revision: Option<flatbuffers::WIPOffset<&'a str>>,
            pub serial_number: Option<flatbuffers::WIPOffset<&'a str>>,
            pub uptime_secs: u64,
            pub capabilities: u32,
            pub max_clients: u8,
        }
        impl<'a> Default for DeviceInfoResponseArgs<'a> {
            #[inline]
            fn default() -> Self {
                DeviceInfoResponseArgs {
                    firmware_version: None,
                    hardware_revision: None,
                    serial_number: None,
                    uptime_secs: 0,
                    capabilities: 0,
                    max_clients: 0,
                }
            }
        }

        pub struct DeviceInfoResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DeviceInfoResponseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_firmware_version(
                &mut self,
                firmware_version: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DeviceInfoResponse::VT_FIRMWARE_VERSION,
                    firmware_version,
                );
            }
            #[inline]
            pub fn add_hardware_revision(
                &mut self,
                hardware_revision: flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DeviceInfoResponse::VT_HARDWARE_REVISION,
                    hardware_revision,
                );
            }
            #[inline]
            pub fn add_serial_number(&mut self, serial_number: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DeviceInfoResponse::VT_SERIAL_NUMBER,
                    serial_number,
                );
            }
            #[inline]
            pub fn add_uptime_secs(&mut self, uptime_secs: u64) {
                self.fbb_
                    .push_slot::<u64>(DeviceInfoResponse::VT_UPTIME_SECS, uptime_secs, 0);
            }
            #[inline]
            pub fn add_capabilities(&mut self, capabilities: u32) {
                self.fbb_
                    .push_slot::<u32>(DeviceInfoResponse::VT_CAPABILITIES, capabilities, 0);
            }
            #[inline]
            pub fn add_max_clients(&mut self, max_clients: u8) {
                self.fbb_
                    .push_slot::<u8>(DeviceInfoResponse::VT_MAX_CLIENTS, max_clients, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DeviceInfoResponseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DeviceInfoResponseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DeviceInfoResponse<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DeviceInfoResponse<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DeviceInfoResponse");
                ds.field("firmware_version", &self.firmware_version());
                ds.field("hardware_revision", &self.hardware_revision());
                ds.field("serial_number", &self.serial_number());
                ds.field("uptime_secs", &self.uptime_secs());
                ds.field("capabilities", &self.capabilities());
                ds.field("max_clients", &self.max_clients());
                ds.finish()
            }
        }
        pub enum AckResponseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct AckResponse<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for AckResponse<'a> {
            type Inner = AckResponse<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> AckResponse<'a> {
            pub const VT_SUCCESS: flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                AckResponse { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args AckResponseArgs<'args>,
            ) -> flatbuffers::WIPOffset<AckResponse<'bldr>> {
                let mut builder = AckResponseBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.add_success(args.success);
                builder.finish()
            }

            #[inline]
            pub fn success(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(AckResponse::VT_SUCCESS, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn message(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(AckResponse::VT_MESSAGE, None)
                }
            }
        }

        impl flatbuffers::Verifiable for AckResponse<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<bool>("success", Self::VT_SUCCESS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct AckResponseArgs<'a> {
            pub success: bool,
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for AckResponseArgs<'a> {
            #[inline]
            fn default() -> Self {
                AckResponseArgs {
                    success: false,
                    message: None,
                }
            }
        }

        pub struct AckResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AckResponseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_success(&mut self, success: bool) {
                self.fbb_
                    .push_slot::<bool>(AckResponse::VT_SUCCESS, success, false);
            }
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    AckResponse::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AckResponseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AckResponseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<AckResponse<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for AckResponse<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("AckResponse");
                ds.field("success", &self.success());
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum TelemetryFrameOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TelemetryFrame<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TelemetryFrame<'a> {
            type Inner = TelemetryFrame<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TelemetryFrame<'a> {
            pub const VT_TIMESTAMP_MS: flatbuffers::VOffsetT = 4;
            pub const VT_STATE: flatbuffers::VOffsetT = 6;
            pub const VT_NH3_PPM: flatbuffers::VOffsetT = 8;
            pub const VT_NH3_AVG_PPM: flatbuffers::VOffsetT = 10;
            pub const VT_FLOW_ML_PER_MIN: flatbuffers::VOffsetT = 12;
            pub const VT_TEMPERATURE_C: flatbuffers::VOffsetT = 14;
            pub const VT_PUMP_DUTY: flatbuffers::VOffsetT = 16;
            pub const VT_UVC_DUTY: flatbuffers::VOffsetT = 18;
            pub const VT_FAULT_FLAGS: flatbuffers::VOffsetT = 20;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TelemetryFrame { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TelemetryFrameArgs,
            ) -> flatbuffers::WIPOffset<TelemetryFrame<'bldr>> {
                let mut builder = TelemetryFrameBuilder::new(_fbb);
                builder.add_timestamp_ms(args.timestamp_ms);
                builder.add_temperature_c(args.temperature_c);
                builder.add_flow_ml_per_min(args.flow_ml_per_min);
                builder.add_nh3_avg_ppm(args.nh3_avg_ppm);
                builder.add_nh3_ppm(args.nh3_ppm);
                builder.add_fault_flags(args.fault_flags);
                builder.add_uvc_duty(args.uvc_duty);
                builder.add_pump_duty(args.pump_duty);
                builder.add_state(args.state);
                builder.finish()
            }

            #[inline]
            pub fn timestamp_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(TelemetryFrame::VT_TIMESTAMP_MS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn state(&self) -> DeviceState {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<DeviceState>(TelemetryFrame::VT_STATE, Some(DeviceState::Idle))
                        .unwrap()
                }
            }
            #[inline]
            pub fn nh3_ppm(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(TelemetryFrame::VT_NH3_PPM, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn nh3_avg_ppm(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(TelemetryFrame::VT_NH3_AVG_PPM, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn flow_ml_per_min(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(TelemetryFrame::VT_FLOW_ML_PER_MIN, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn temperature_c(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(TelemetryFrame::VT_TEMPERATURE_C, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn pump_duty(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(TelemetryFrame::VT_PUMP_DUTY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn uvc_duty(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(TelemetryFrame::VT_UVC_DUTY, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn fault_flags(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(TelemetryFrame::VT_FAULT_FLAGS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for TelemetryFrame<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
                    .visit_field::<DeviceState>("state", Self::VT_STATE, false)?
                    .visit_field::<f32>("nh3_ppm", Self::VT_NH3_PPM, false)?
                    .visit_field::<f32>("nh3_avg_ppm", Self::VT_NH3_AVG_PPM, false)?
                    .visit_field::<f32>("flow_ml_per_min", Self::VT_FLOW_ML_PER_MIN, false)?
                    .visit_field::<f32>("temperature_c", Self::VT_TEMPERATURE_C, false)?
                    .visit_field::<u8>("pump_duty", Self::VT_PUMP_DUTY, false)?
                    .visit_field::<u8>("uvc_duty", Self::VT_UVC_DUTY, false)?
                    .visit_field::<u8>("fault_flags", Self::VT_FAULT_FLAGS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TelemetryFrameArgs {
            pub timestamp_ms: u64,
            pub state: DeviceState,
            pub nh3_ppm: f32,
            pub nh3_avg_ppm: f32,
            pub flow_ml_per_min: f32,
            pub temperature_c: f32,
            pub pump_duty: u8,
            pub uvc_duty: u8,
            pub fault_flags: u8,
        }
        impl<'a> Default for TelemetryFrameArgs {
            #[inline]
            fn default() -> Self {
                TelemetryFrameArgs {
                    timestamp_ms: 0,
                    state: DeviceState::Idle,
                    nh3_ppm: 0.0,
                    nh3_avg_ppm: 0.0,
                    flow_ml_per_min: 0.0,
                    temperature_c: 0.0,
                    pump_duty: 0,
                    uvc_duty: 0,
                    fault_flags: 0,
                }
            }
        }

        pub struct TelemetryFrameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TelemetryFrameBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(TelemetryFrame::VT_TIMESTAMP_MS, timestamp_ms, 0);
            }
            #[inline]
            pub fn add_state(&mut self, state: DeviceState) {
                self.fbb_.push_slot::<DeviceState>(
                    TelemetryFrame::VT_STATE,
                    state,
                    DeviceState::Idle,
                );
            }
            #[inline]
            pub fn add_nh3_ppm(&mut self, nh3_ppm: f32) {
                self.fbb_
                    .push_slot::<f32>(TelemetryFrame::VT_NH3_PPM, nh3_ppm, 0.0);
            }
            #[inline]
            pub fn add_nh3_avg_ppm(&mut self, nh3_avg_ppm: f32) {
                self.fbb_
                    .push_slot::<f32>(TelemetryFrame::VT_NH3_AVG_PPM, nh3_avg_ppm, 0.0);
            }
            #[inline]
            pub fn add_flow_ml_per_min(&mut self, flow_ml_per_min: f32) {
                self.fbb_.push_slot::<f32>(
                    TelemetryFrame::VT_FLOW_ML_PER_MIN,
                    flow_ml_per_min,
                    0.0,
                );
            }
            #[inline]
            pub fn add_temperature_c(&mut self, temperature_c: f32) {
                self.fbb_
                    .push_slot::<f32>(TelemetryFrame::VT_TEMPERATURE_C, temperature_c, 0.0);
            }
            #[inline]
            pub fn add_pump_duty(&mut self, pump_duty: u8) {
                self.fbb_
                    .push_slot::<u8>(TelemetryFrame::VT_PUMP_DUTY, pump_duty, 0);
            }
            #[inline]
            pub fn add_uvc_duty(&mut self, uvc_duty: u8) {
                self.fbb_
                    .push_slot::<u8>(TelemetryFrame::VT_UVC_DUTY, uvc_duty, 0);
            }
            #[inline]
            pub fn add_fault_flags(&mut self, fault_flags: u8) {
                self.fbb_
                    .push_slot::<u8>(TelemetryFrame::VT_FAULT_FLAGS, fault_flags, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TelemetryFrameBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TelemetryFrameBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TelemetryFrame<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TelemetryFrame<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TelemetryFrame");
                ds.field("timestamp_ms", &self.timestamp_ms());
                ds.field("state", &self.state());
                ds.field("nh3_ppm", &self.nh3_ppm());
                ds.field("nh3_avg_ppm", &self.nh3_avg_ppm());
                ds.field("flow_ml_per_min", &self.flow_ml_per_min());
                ds.field("temperature_c", &self.temperature_c());
                ds.field("pump_duty", &self.pump_duty());
                ds.field("uvc_duty", &self.uvc_duty());
                ds.field("fault_flags", &self.fault_flags());
                ds.finish()
            }
        }
        pub enum StateChangeEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct StateChangeEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for StateChangeEvent<'a> {
            type Inner = StateChangeEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> StateChangeEvent<'a> {
            pub const VT_FROM_STATE: flatbuffers::VOffsetT = 4;
            pub const VT_TO_STATE: flatbuffers::VOffsetT = 6;
            pub const VT_TIMESTAMP_MS: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                StateChangeEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args StateChangeEventArgs,
            ) -> flatbuffers::WIPOffset<StateChangeEvent<'bldr>> {
                let mut builder = StateChangeEventBuilder::new(_fbb);
                builder.add_timestamp_ms(args.timestamp_ms);
                builder.add_to_state(args.to_state);
                builder.add_from_state(args.from_state);
                builder.finish()
            }

            #[inline]
            pub fn from_state(&self) -> DeviceState {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<DeviceState>(
                            StateChangeEvent::VT_FROM_STATE,
                            Some(DeviceState::Idle),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn to_state(&self) -> DeviceState {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<DeviceState>(StateChangeEvent::VT_TO_STATE, Some(DeviceState::Idle))
                        .unwrap()
                }
            }
            #[inline]
            pub fn timestamp_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(StateChangeEvent::VT_TIMESTAMP_MS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for StateChangeEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<DeviceState>("from_state", Self::VT_FROM_STATE, false)?
                    .visit_field::<DeviceState>("to_state", Self::VT_TO_STATE, false)?
                    .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct StateChangeEventArgs {
            pub from_state: DeviceState,
            pub to_state: DeviceState,
            pub timestamp_ms: u64,
        }
        impl<'a> Default for StateChangeEventArgs {
            #[inline]
            fn default() -> Self {
                StateChangeEventArgs {
                    from_state: DeviceState::Idle,
                    to_state: DeviceState::Idle,
                    timestamp_ms: 0,
                }
            }
        }

        pub struct StateChangeEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StateChangeEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_from_state(&mut self, from_state: DeviceState) {
                self.fbb_.push_slot::<DeviceState>(
                    StateChangeEvent::VT_FROM_STATE,
                    from_state,
                    DeviceState::Idle,
                );
            }
            #[inline]
            pub fn add_to_state(&mut self, to_state: DeviceState) {
                self.fbb_.push_slot::<DeviceState>(
                    StateChangeEvent::VT_TO_STATE,
                    to_state,
                    DeviceState::Idle,
                );
            }
            #[inline]
            pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(StateChangeEvent::VT_TIMESTAMP_MS, timestamp_ms, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> StateChangeEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                StateChangeEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<StateChangeEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for StateChangeEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("StateChangeEvent");
                ds.field("from_state", &self.from_state());
                ds.field("to_state", &self.to_state());
                ds.field("timestamp_ms", &self.timestamp_ms());
                ds.finish()
            }
        }
        pub enum FaultEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct FaultEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FaultEvent<'a> {
            type Inner = FaultEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> FaultEvent<'a> {
            pub const VT_FAULT_FLAGS: flatbuffers::VOffsetT = 4;
            pub const VT_IS_CLEAR: flatbuffers::VOffsetT = 6;
            pub const VT_TIMESTAMP_MS: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FaultEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args FaultEventArgs,
            ) -> flatbuffers::WIPOffset<FaultEvent<'bldr>> {
                let mut builder = FaultEventBuilder::new(_fbb);
                builder.add_timestamp_ms(args.timestamp_ms);
                builder.add_is_clear(args.is_clear);
                builder.add_fault_flags(args.fault_flags);
                builder.finish()
            }

            #[inline]
            pub fn fault_flags(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(FaultEvent::VT_FAULT_FLAGS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn is_clear(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(FaultEvent::VT_IS_CLEAR, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn timestamp_ms(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(FaultEvent::VT_TIMESTAMP_MS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for FaultEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u8>("fault_flags", Self::VT_FAULT_FLAGS, false)?
                    .visit_field::<bool>("is_clear", Self::VT_IS_CLEAR, false)?
                    .visit_field::<u64>("timestamp_ms", Self::VT_TIMESTAMP_MS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct FaultEventArgs {
            pub fault_flags: u8,
            pub is_clear: bool,
            pub timestamp_ms: u64,
        }
        impl<'a> Default for FaultEventArgs {
            #[inline]
            fn default() -> Self {
                FaultEventArgs {
                    fault_flags: 0,
                    is_clear: false,
                    timestamp_ms: 0,
                }
            }
        }

        pub struct FaultEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FaultEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_fault_flags(&mut self, fault_flags: u8) {
                self.fbb_
                    .push_slot::<u8>(FaultEvent::VT_FAULT_FLAGS, fault_flags, 0);
            }
            #[inline]
            pub fn add_is_clear(&mut self, is_clear: bool) {
                self.fbb_
                    .push_slot::<bool>(FaultEvent::VT_IS_CLEAR, is_clear, false);
            }
            #[inline]
            pub fn add_timestamp_ms(&mut self, timestamp_ms: u64) {
                self.fbb_
                    .push_slot::<u64>(FaultEvent::VT_TIMESTAMP_MS, timestamp_ms, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> FaultEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                FaultEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FaultEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for FaultEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("FaultEvent");
                ds.field("fault_flags", &self.fault_flags());
                ds.field("is_clear", &self.is_clear());
                ds.field("timestamp_ms", &self.timestamp_ms());
                ds.finish()
            }
        }
        pub enum AuthChallengeRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct AuthChallengeRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for AuthChallengeRequest<'a> {
            type Inner = AuthChallengeRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> AuthChallengeRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                AuthChallengeRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args AuthChallengeRequestArgs,
            ) -> flatbuffers::WIPOffset<AuthChallengeRequest<'bldr>> {
                let mut builder = AuthChallengeRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for AuthChallengeRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct AuthChallengeRequestArgs {}
        impl<'a> Default for AuthChallengeRequestArgs {
            #[inline]
            fn default() -> Self {
                AuthChallengeRequestArgs {}
            }
        }

        pub struct AuthChallengeRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AuthChallengeRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AuthChallengeRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AuthChallengeRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<AuthChallengeRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for AuthChallengeRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("AuthChallengeRequest");
                ds.finish()
            }
        }
        pub enum AuthVerifyRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct AuthVerifyRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for AuthVerifyRequest<'a> {
            type Inner = AuthVerifyRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> AuthVerifyRequest<'a> {
            pub const VT_SESSION_ID: flatbuffers::VOffsetT = 4;
            pub const VT_HMAC: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                AuthVerifyRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args AuthVerifyRequestArgs<'args>,
            ) -> flatbuffers::WIPOffset<AuthVerifyRequest<'bldr>> {
                let mut builder = AuthVerifyRequestBuilder::new(_fbb);
                if let Some(x) = args.hmac {
                    builder.add_hmac(x);
                }
                builder.add_session_id(args.session_id);
                builder.finish()
            }

            #[inline]
            pub fn session_id(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(AuthVerifyRequest::VT_SESSION_ID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn hmac(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            AuthVerifyRequest::VT_HMAC,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for AuthVerifyRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("session_id", Self::VT_SESSION_ID, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "hmac",
                        Self::VT_HMAC,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct AuthVerifyRequestArgs<'a> {
            pub session_id: u32,
            pub hmac: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for AuthVerifyRequestArgs<'a> {
            #[inline]
            fn default() -> Self {
                AuthVerifyRequestArgs {
                    session_id: 0,
                    hmac: None,
                }
            }
        }

        pub struct AuthVerifyRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AuthVerifyRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_session_id(&mut self, session_id: u32) {
                self.fbb_
                    .push_slot::<u32>(AuthVerifyRequest::VT_SESSION_ID, session_id, 0);
            }
            #[inline]
            pub fn add_hmac(&mut self, hmac: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    AuthVerifyRequest::VT_HMAC,
                    hmac,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AuthVerifyRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AuthVerifyRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<AuthVerifyRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for AuthVerifyRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("AuthVerifyRequest");
                ds.field("session_id", &self.session_id());
                ds.field("hmac", &self.hmac());
                ds.finish()
            }
        }
        pub enum AuthChallengeResponseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct AuthChallengeResponse<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for AuthChallengeResponse<'a> {
            type Inner = AuthChallengeResponse<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> AuthChallengeResponse<'a> {
            pub const VT_NONCE: flatbuffers::VOffsetT = 4;
            pub const VT_SESSION_ID: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                AuthChallengeResponse { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args AuthChallengeResponseArgs<'args>,
            ) -> flatbuffers::WIPOffset<AuthChallengeResponse<'bldr>> {
                let mut builder = AuthChallengeResponseBuilder::new(_fbb);
                builder.add_session_id(args.session_id);
                if let Some(x) = args.nonce {
                    builder.add_nonce(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn nonce(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            AuthChallengeResponse::VT_NONCE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn session_id(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(AuthChallengeResponse::VT_SESSION_ID, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for AuthChallengeResponse<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "nonce",
                        Self::VT_NONCE,
                        false,
                    )?
                    .visit_field::<u32>("session_id", Self::VT_SESSION_ID, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct AuthChallengeResponseArgs<'a> {
            pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub session_id: u32,
        }
        impl<'a> Default for AuthChallengeResponseArgs<'a> {
            #[inline]
            fn default() -> Self {
                AuthChallengeResponseArgs {
                    nonce: None,
                    session_id: 0,
                }
            }
        }

        pub struct AuthChallengeResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AuthChallengeResponseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_nonce(
                &mut self,
                nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    AuthChallengeResponse::VT_NONCE,
                    nonce,
                );
            }
            #[inline]
            pub fn add_session_id(&mut self, session_id: u32) {
                self.fbb_
                    .push_slot::<u32>(AuthChallengeResponse::VT_SESSION_ID, session_id, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AuthChallengeResponseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AuthChallengeResponseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<AuthChallengeResponse<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for AuthChallengeResponse<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("AuthChallengeResponse");
                ds.field("nonce", &self.nonce());
                ds.field("session_id", &self.session_id());
                ds.finish()
            }
        }
        pub enum AuthVerifyResponseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct AuthVerifyResponse<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for AuthVerifyResponse<'a> {
            type Inner = AuthVerifyResponse<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> AuthVerifyResponse<'a> {
            pub const VT_SUCCESS: flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                AuthVerifyResponse { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args AuthVerifyResponseArgs<'args>,
            ) -> flatbuffers::WIPOffset<AuthVerifyResponse<'bldr>> {
                let mut builder = AuthVerifyResponseBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.add_success(args.success);
                builder.finish()
            }

            #[inline]
            pub fn success(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(AuthVerifyResponse::VT_SUCCESS, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn message(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        AuthVerifyResponse::VT_MESSAGE,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for AuthVerifyResponse<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<bool>("success", Self::VT_SUCCESS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct AuthVerifyResponseArgs<'a> {
            pub success: bool,
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for AuthVerifyResponseArgs<'a> {
            #[inline]
            fn default() -> Self {
                AuthVerifyResponseArgs {
                    success: false,
                    message: None,
                }
            }
        }

        pub struct AuthVerifyResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AuthVerifyResponseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_success(&mut self, success: bool) {
                self.fbb_
                    .push_slot::<bool>(AuthVerifyResponse::VT_SUCCESS, success, false);
            }
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    AuthVerifyResponse::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AuthVerifyResponseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AuthVerifyResponseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<AuthVerifyResponse<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for AuthVerifyResponse<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("AuthVerifyResponse");
                ds.field("success", &self.success());
                ds.field("message", &self.message());
                ds.finish()
            }
        }
        pub enum ProvisionCertRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Provision X.509 certificates onto the device over an authenticated
        /// PSK session. After successful provisioning the device switches to
        /// CertOnly or PskAndCert mode.
        pub struct ProvisionCertRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ProvisionCertRequest<'a> {
            type Inner = ProvisionCertRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ProvisionCertRequest<'a> {
            pub const VT_CA_CERT: flatbuffers::VOffsetT = 4;
            pub const VT_DEVICE_CERT: flatbuffers::VOffsetT = 6;
            pub const VT_DEVICE_KEY: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ProvisionCertRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ProvisionCertRequestArgs<'args>,
            ) -> flatbuffers::WIPOffset<ProvisionCertRequest<'bldr>> {
                let mut builder = ProvisionCertRequestBuilder::new(_fbb);
                if let Some(x) = args.device_key {
                    builder.add_device_key(x);
                }
                if let Some(x) = args.device_cert {
                    builder.add_device_cert(x);
                }
                if let Some(x) = args.ca_cert {
                    builder.add_ca_cert(x);
                }
                builder.finish()
            }

            /// PEM-encoded CA certificate chain.
            #[inline]
            pub fn ca_cert(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            ProvisionCertRequest::VT_CA_CERT,
                            None,
                        )
                }
            }
            /// PEM-encoded device certificate.
            #[inline]
            pub fn device_cert(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            ProvisionCertRequest::VT_DEVICE_CERT,
                            None,
                        )
                }
            }
            /// PEM-encoded device private key.
            #[inline]
            pub fn device_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            ProvisionCertRequest::VT_DEVICE_KEY,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for ProvisionCertRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "ca_cert",
                        Self::VT_CA_CERT,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "device_cert",
                        Self::VT_DEVICE_CERT,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "device_key",
                        Self::VT_DEVICE_KEY,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ProvisionCertRequestArgs<'a> {
            pub ca_cert: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub device_cert: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub device_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for ProvisionCertRequestArgs<'a> {
            #[inline]
            fn default() -> Self {
                ProvisionCertRequestArgs {
                    ca_cert: None,
                    device_cert: None,
                    device_key: None,
                }
            }
        }

        pub struct ProvisionCertRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProvisionCertRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_ca_cert(
                &mut self,
                ca_cert: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ProvisionCertRequest::VT_CA_CERT,
                    ca_cert,
                );
            }
            #[inline]
            pub fn add_device_cert(
                &mut self,
                device_cert: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ProvisionCertRequest::VT_DEVICE_CERT,
                    device_cert,
                );
            }
            #[inline]
            pub fn add_device_key(
                &mut self,
                device_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ProvisionCertRequest::VT_DEVICE_KEY,
                    device_key,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ProvisionCertRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ProvisionCertRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ProvisionCertRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ProvisionCertRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ProvisionCertRequest");
                ds.field("ca_cert", &self.ca_cert());
                ds.field("device_cert", &self.device_cert());
                ds.field("device_key", &self.device_key());
                ds.finish()
            }
        }
        pub enum GetCertStatusRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Query the current TLS certificate status.
        pub struct GetCertStatusRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GetCertStatusRequest<'a> {
            type Inner = GetCertStatusRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GetCertStatusRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GetCertStatusRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args GetCertStatusRequestArgs,
            ) -> flatbuffers::WIPOffset<GetCertStatusRequest<'bldr>> {
                let mut builder = GetCertStatusRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for GetCertStatusRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct GetCertStatusRequestArgs {}
        impl<'a> Default for GetCertStatusRequestArgs {
            #[inline]
            fn default() -> Self {
                GetCertStatusRequestArgs {}
            }
        }

        pub struct GetCertStatusRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetCertStatusRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> GetCertStatusRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                GetCertStatusRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GetCertStatusRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GetCertStatusRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GetCertStatusRequest");
                ds.finish()
            }
        }
        pub enum CertStatusResponseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Certificate status response.
        pub struct CertStatusResponse<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CertStatusResponse<'a> {
            type Inner = CertStatusResponse<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> CertStatusResponse<'a> {
            pub const VT_MODE: flatbuffers::VOffsetT = 4;
            pub const VT_CA_FINGERPRINT: flatbuffers::VOffsetT = 6;
            pub const VT_DEVICE_SERIAL: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CertStatusResponse { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CertStatusResponseArgs<'args>,
            ) -> flatbuffers::WIPOffset<CertStatusResponse<'bldr>> {
                let mut builder = CertStatusResponseBuilder::new(_fbb);
                if let Some(x) = args.device_serial {
                    builder.add_device_serial(x);
                }
                if let Some(x) = args.ca_fingerprint {
                    builder.add_ca_fingerprint(x);
                }
                builder.add_mode(args.mode);
                builder.finish()
            }

            #[inline]
            pub fn mode(&self) -> TlsMode {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TlsMode>(CertStatusResponse::VT_MODE, Some(TlsMode::PskOnly))
                        .unwrap()
                }
            }
            /// SHA-256 fingerprint of the installed CA certificate.
            #[inline]
            pub fn ca_fingerprint(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            CertStatusResponse::VT_CA_FINGERPRINT,
                            None,
                        )
                }
            }
            /// Serial number from the device certificate.
            #[inline]
            pub fn device_serial(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        CertStatusResponse::VT_DEVICE_SERIAL,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for CertStatusResponse<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<TlsMode>("mode", Self::VT_MODE, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "ca_fingerprint",
                        Self::VT_CA_FINGERPRINT,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "device_serial",
                        Self::VT_DEVICE_SERIAL,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct CertStatusResponseArgs<'a> {
            pub mode: TlsMode,
            pub ca_fingerprint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
            pub device_serial: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for CertStatusResponseArgs<'a> {
            #[inline]
            fn default() -> Self {
                CertStatusResponseArgs {
                    mode: TlsMode::PskOnly,
                    ca_fingerprint: None,
                    device_serial: None,
                }
            }
        }

        pub struct CertStatusResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CertStatusResponseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_mode(&mut self, mode: TlsMode) {
                self.fbb_
                    .push_slot::<TlsMode>(CertStatusResponse::VT_MODE, mode, TlsMode::PskOnly);
            }
            #[inline]
            pub fn add_ca_fingerprint(
                &mut self,
                ca_fingerprint: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CertStatusResponse::VT_CA_FINGERPRINT,
                    ca_fingerprint,
                );
            }
            #[inline]
            pub fn add_device_serial(&mut self, device_serial: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CertStatusResponse::VT_DEVICE_SERIAL,
                    device_serial,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CertStatusResponseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CertStatusResponseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CertStatusResponse<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CertStatusResponse<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CertStatusResponse");
                ds.field("mode", &self.mode());
                ds.field("ca_fingerprint", &self.ca_fingerprint());
                ds.field("device_serial", &self.device_serial());
                ds.finish()
            }
        }
        pub enum OtaBeginRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct OtaBeginRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for OtaBeginRequest<'a> {
            type Inner = OtaBeginRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> OtaBeginRequest<'a> {
            pub const VT_FIRMWARE_SIZE: flatbuffers::VOffsetT = 4;
            pub const VT_SHA256: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                OtaBeginRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args OtaBeginRequestArgs<'args>,
            ) -> flatbuffers::WIPOffset<OtaBeginRequest<'bldr>> {
                let mut builder = OtaBeginRequestBuilder::new(_fbb);
                if let Some(x) = args.sha256 {
                    builder.add_sha256(x);
                }
                builder.add_firmware_size(args.firmware_size);
                builder.finish()
            }

            #[inline]
            pub fn firmware_size(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(OtaBeginRequest::VT_FIRMWARE_SIZE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn sha256(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            OtaBeginRequest::VT_SHA256,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for OtaBeginRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("firmware_size", Self::VT_FIRMWARE_SIZE, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "sha256",
                        Self::VT_SHA256,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct OtaBeginRequestArgs<'a> {
            pub firmware_size: u32,
            pub sha256: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for OtaBeginRequestArgs<'a> {
            #[inline]
            fn default() -> Self {
                OtaBeginRequestArgs {
                    firmware_size: 0,
                    sha256: None,
                }
            }
        }

        pub struct OtaBeginRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OtaBeginRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_firmware_size(&mut self, firmware_size: u32) {
                self.fbb_
                    .push_slot::<u32>(OtaBeginRequest::VT_FIRMWARE_SIZE, firmware_size, 0);
            }
            #[inline]
            pub fn add_sha256(
                &mut self,
                sha256: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    OtaBeginRequest::VT_SHA256,
                    sha256,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OtaBeginRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OtaBeginRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<OtaBeginRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for OtaBeginRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("OtaBeginRequest");
                ds.field("firmware_size", &self.firmware_size());
                ds.field("sha256", &self.sha256());
                ds.finish()
            }
        }
        pub enum OtaChunkRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct OtaChunkRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for OtaChunkRequest<'a> {
            type Inner = OtaChunkRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> OtaChunkRequest<'a> {
            pub const VT_OFFSET: flatbuffers::VOffsetT = 4;
            pub const VT_DATA: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                OtaChunkRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args OtaChunkRequestArgs<'args>,
            ) -> flatbuffers::WIPOffset<OtaChunkRequest<'bldr>> {
                let mut builder = OtaChunkRequestBuilder::new(_fbb);
                if let Some(x) = args.data {
                    builder.add_data(x);
                }
                builder.add_offset(args.offset);
                builder.finish()
            }

            #[inline]
            pub fn offset(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(OtaChunkRequest::VT_OFFSET, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                            OtaChunkRequest::VT_DATA,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for OtaChunkRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("offset", Self::VT_OFFSET, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                        "data",
                        Self::VT_DATA,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct OtaChunkRequestArgs<'a> {
            pub offset: u32,
            pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        }
        impl<'a> Default for OtaChunkRequestArgs<'a> {
            #[inline]
            fn default() -> Self {
                OtaChunkRequestArgs {
                    offset: 0,
                    data: None,
                }
            }
        }

        pub struct OtaChunkRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OtaChunkRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_offset(&mut self, offset: u32) {
                self.fbb_
                    .push_slot::<u32>(OtaChunkRequest::VT_OFFSET, offset, 0);
            }
            #[inline]
            pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(OtaChunkRequest::VT_DATA, data);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OtaChunkRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OtaChunkRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<OtaChunkRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for OtaChunkRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("OtaChunkRequest");
                ds.field("offset", &self.offset());
                ds.field("data", &self.data());
                ds.finish()
            }
        }
        pub enum OtaFinalizeRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct OtaFinalizeRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for OtaFinalizeRequest<'a> {
            type Inner = OtaFinalizeRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> OtaFinalizeRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                OtaFinalizeRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args OtaFinalizeRequestArgs,
            ) -> flatbuffers::WIPOffset<OtaFinalizeRequest<'bldr>> {
                let mut builder = OtaFinalizeRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for OtaFinalizeRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct OtaFinalizeRequestArgs {}
        impl<'a> Default for OtaFinalizeRequestArgs {
            #[inline]
            fn default() -> Self {
                OtaFinalizeRequestArgs {}
            }
        }

        pub struct OtaFinalizeRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OtaFinalizeRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OtaFinalizeRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OtaFinalizeRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<OtaFinalizeRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for OtaFinalizeRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("OtaFinalizeRequest");
                ds.finish()
            }
        }
        pub enum OtaResponseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct OtaResponse<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for OtaResponse<'a> {
            type Inner = OtaResponse<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> OtaResponse<'a> {
            pub const VT_SUCCESS: flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;
            pub const VT_BYTES_WRITTEN: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                OtaResponse { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args OtaResponseArgs<'args>,
            ) -> flatbuffers::WIPOffset<OtaResponse<'bldr>> {
                let mut builder = OtaResponseBuilder::new(_fbb);
                builder.add_bytes_written(args.bytes_written);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.add_success(args.success);
                builder.finish()
            }

            #[inline]
            pub fn success(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(OtaResponse::VT_SUCCESS, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn message(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(OtaResponse::VT_MESSAGE, None)
                }
            }
            #[inline]
            pub fn bytes_written(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(OtaResponse::VT_BYTES_WRITTEN, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for OtaResponse<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<bool>("success", Self::VT_SUCCESS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        false,
                    )?
                    .visit_field::<u32>("bytes_written", Self::VT_BYTES_WRITTEN, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct OtaResponseArgs<'a> {
            pub success: bool,
            pub message: Option<flatbuffers::WIPOffset<&'a str>>,
            pub bytes_written: u32,
        }
        impl<'a> Default for OtaResponseArgs<'a> {
            #[inline]
            fn default() -> Self {
                OtaResponseArgs {
                    success: false,
                    message: None,
                    bytes_written: 0,
                }
            }
        }

        pub struct OtaResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OtaResponseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_success(&mut self, success: bool) {
                self.fbb_
                    .push_slot::<bool>(OtaResponse::VT_SUCCESS, success, false);
            }
            #[inline]
            pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    OtaResponse::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn add_bytes_written(&mut self, bytes_written: u32) {
                self.fbb_
                    .push_slot::<u32>(OtaResponse::VT_BYTES_WRITTEN, bytes_written, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OtaResponseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OtaResponseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<OtaResponse<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for OtaResponse<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("OtaResponse");
                ds.field("success", &self.success());
                ds.field("message", &self.message());
                ds.field("bytes_written", &self.bytes_written());
                ds.finish()
            }
        }
        pub enum OtaProgressEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Async OTA progress event pushed to clients during firmware upload.
        pub struct OtaProgressEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for OtaProgressEvent<'a> {
            type Inner = OtaProgressEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> OtaProgressEvent<'a> {
            pub const VT_BYTES_WRITTEN: flatbuffers::VOffsetT = 4;
            pub const VT_TOTAL_BYTES: flatbuffers::VOffsetT = 6;
            pub const VT_PERCENT: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                OtaProgressEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args OtaProgressEventArgs,
            ) -> flatbuffers::WIPOffset<OtaProgressEvent<'bldr>> {
                let mut builder = OtaProgressEventBuilder::new(_fbb);
                builder.add_total_bytes(args.total_bytes);
                builder.add_bytes_written(args.bytes_written);
                builder.add_percent(args.percent);
                builder.finish()
            }

            #[inline]
            pub fn bytes_written(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(OtaProgressEvent::VT_BYTES_WRITTEN, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn total_bytes(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(OtaProgressEvent::VT_TOTAL_BYTES, Some(0))
                        .unwrap()
                }
            }
            /// 0-100 percent complete.
            #[inline]
            pub fn percent(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u8>(OtaProgressEvent::VT_PERCENT, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for OtaProgressEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u32>("bytes_written", Self::VT_BYTES_WRITTEN, false)?
                    .visit_field::<u32>("total_bytes", Self::VT_TOTAL_BYTES, false)?
                    .visit_field::<u8>("percent", Self::VT_PERCENT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct OtaProgressEventArgs {
            pub bytes_written: u32,
            pub total_bytes: u32,
            pub percent: u8,
        }
        impl<'a> Default for OtaProgressEventArgs {
            #[inline]
            fn default() -> Self {
                OtaProgressEventArgs {
                    bytes_written: 0,
                    total_bytes: 0,
                    percent: 0,
                }
            }
        }

        pub struct OtaProgressEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OtaProgressEventBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_bytes_written(&mut self, bytes_written: u32) {
                self.fbb_
                    .push_slot::<u32>(OtaProgressEvent::VT_BYTES_WRITTEN, bytes_written, 0);
            }
            #[inline]
            pub fn add_total_bytes(&mut self, total_bytes: u32) {
                self.fbb_
                    .push_slot::<u32>(OtaProgressEvent::VT_TOTAL_BYTES, total_bytes, 0);
            }
            #[inline]
            pub fn add_percent(&mut self, percent: u8) {
                self.fbb_
                    .push_slot::<u8>(OtaProgressEvent::VT_PERCENT, percent, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OtaProgressEventBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OtaProgressEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<OtaProgressEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for OtaProgressEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("OtaProgressEvent");
                ds.field("bytes_written", &self.bytes_written());
                ds.field("total_bytes", &self.total_bytes());
                ds.field("percent", &self.percent());
                ds.finish()
            }
        }
        pub enum GetDiagnosticsRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GetDiagnosticsRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GetDiagnosticsRequest<'a> {
            type Inner = GetDiagnosticsRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GetDiagnosticsRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GetDiagnosticsRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args GetDiagnosticsRequestArgs,
            ) -> flatbuffers::WIPOffset<GetDiagnosticsRequest<'bldr>> {
                let mut builder = GetDiagnosticsRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for GetDiagnosticsRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct GetDiagnosticsRequestArgs {}
        impl<'a> Default for GetDiagnosticsRequestArgs {
            #[inline]
            fn default() -> Self {
                GetDiagnosticsRequestArgs {}
            }
        }

        pub struct GetDiagnosticsRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetDiagnosticsRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> GetDiagnosticsRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                GetDiagnosticsRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GetDiagnosticsRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GetDiagnosticsRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GetDiagnosticsRequest");
                ds.finish()
            }
        }
        pub enum ClearDiagnosticsRequestOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ClearDiagnosticsRequest<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ClearDiagnosticsRequest<'a> {
            type Inner = ClearDiagnosticsRequest<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ClearDiagnosticsRequest<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ClearDiagnosticsRequest { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                _args: &'args ClearDiagnosticsRequestArgs,
            ) -> flatbuffers::WIPOffset<ClearDiagnosticsRequest<'bldr>> {
                let mut builder = ClearDiagnosticsRequestBuilder::new(_fbb);
                builder.finish()
            }
        }

        impl flatbuffers::Verifiable for ClearDiagnosticsRequest<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct ClearDiagnosticsRequestArgs {}
        impl<'a> Default for ClearDiagnosticsRequestArgs {
            #[inline]
            fn default() -> Self {
                ClearDiagnosticsRequestArgs {}
            }
        }

        pub struct ClearDiagnosticsRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ClearDiagnosticsRequestBuilder<'a, 'b, A> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ClearDiagnosticsRequestBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ClearDiagnosticsRequestBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ClearDiagnosticsRequest<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ClearDiagnosticsRequest<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ClearDiagnosticsRequest");
                ds.finish()
            }
        }
        pub enum CrashEntryFbsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CrashEntryFbs<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CrashEntryFbs<'a> {
            type Inner = CrashEntryFbs<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> CrashEntryFbs<'a> {
            pub const VT_UPTIME_SECS: flatbuffers::VOffsetT = 4;
            pub const VT_REASON: flatbuffers::VOffsetT = 6;
            pub const VT_PC: flatbuffers::VOffsetT = 8;
            pub const VT_BACKTRACE: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CrashEntryFbs { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CrashEntryFbsArgs<'args>,
            ) -> flatbuffers::WIPOffset<CrashEntryFbs<'bldr>> {
                let mut builder = CrashEntryFbsBuilder::new(_fbb);
                builder.add_uptime_secs(args.uptime_secs);
                if let Some(x) = args.backtrace {
                    builder.add_backtrace(x);
                }
                builder.add_pc(args.pc);
                if let Some(x) = args.reason {
                    builder.add_reason(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn uptime_secs(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(CrashEntryFbs::VT_UPTIME_SECS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn reason(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(CrashEntryFbs::VT_REASON, None)
                }
            }
            #[inline]
            pub fn pc(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(CrashEntryFbs::VT_PC, Some(0)).unwrap() }
            }
            #[inline]
            pub fn backtrace(&self) -> Option<flatbuffers::Vector<'a, u32>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                            CrashEntryFbs::VT_BACKTRACE,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for CrashEntryFbs<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("uptime_secs", Self::VT_UPTIME_SECS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "reason",
                        Self::VT_REASON,
                        false,
                    )?
                    .visit_field::<u32>("pc", Self::VT_PC, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                        "backtrace",
                        Self::VT_BACKTRACE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct CrashEntryFbsArgs<'a> {
            pub uptime_secs: u64,
            pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
            pub pc: u32,
            pub backtrace: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
        }
        impl<'a> Default for CrashEntryFbsArgs<'a> {
            #[inline]
            fn default() -> Self {
                CrashEntryFbsArgs {
                    uptime_secs: 0,
                    reason: None,
                    pc: 0,
                    backtrace: None,
                }
            }
        }

        pub struct CrashEntryFbsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CrashEntryFbsBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_uptime_secs(&mut self, uptime_secs: u64) {
                self.fbb_
                    .push_slot::<u64>(CrashEntryFbs::VT_UPTIME_SECS, uptime_secs, 0);
            }
            #[inline]
            pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CrashEntryFbs::VT_REASON,
                    reason,
                );
            }
            #[inline]
            pub fn add_pc(&mut self, pc: u32) {
                self.fbb_.push_slot::<u32>(CrashEntryFbs::VT_PC, pc, 0);
            }
            #[inline]
            pub fn add_backtrace(
                &mut self,
                backtrace: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    CrashEntryFbs::VT_BACKTRACE,
                    backtrace,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CrashEntryFbsBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CrashEntryFbsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CrashEntryFbs<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CrashEntryFbs<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CrashEntryFbs");
                ds.field("uptime_secs", &self.uptime_secs());
                ds.field("reason", &self.reason());
                ds.field("pc", &self.pc());
                ds.field("backtrace", &self.backtrace());
                ds.finish()
            }
        }
        pub enum DiagnosticsResponseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DiagnosticsResponse<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DiagnosticsResponse<'a> {
            type Inner = DiagnosticsResponse<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DiagnosticsResponse<'a> {
            pub const VT_UPTIME_SECS: flatbuffers::VOffsetT = 4;
            pub const VT_CONTROL_CYCLES: flatbuffers::VOffsetT = 6;
            pub const VT_FAULT_COUNT: flatbuffers::VOffsetT = 8;
            pub const VT_CRASH_COUNT: flatbuffers::VOffsetT = 10;
            pub const VT_HEAP_FREE: flatbuffers::VOffsetT = 12;
            pub const VT_HEAP_MIN_FREE: flatbuffers::VOffsetT = 14;
            pub const VT_WIFI_RSSI: flatbuffers::VOffsetT = 16;
            pub const VT_NVS_FREE_ENTRIES: flatbuffers::VOffsetT = 18;
            pub const VT_ULP_WAKE_COUNT: flatbuffers::VOffsetT = 20;
            pub const VT_CRASH_ENTRIES: flatbuffers::VOffsetT = 22;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DiagnosticsResponse { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args DiagnosticsResponseArgs<'args>,
            ) -> flatbuffers::WIPOffset<DiagnosticsResponse<'bldr>> {
                let mut builder = DiagnosticsResponseBuilder::new(_fbb);
                builder.add_control_cycles(args.control_cycles);
                builder.add_uptime_secs(args.uptime_secs);
                if let Some(x) = args.crash_entries {
                    builder.add_crash_entries(x);
                }
                builder.add_ulp_wake_count(args.ulp_wake_count);
                builder.add_nvs_free_entries(args.nvs_free_entries);
                builder.add_heap_min_free(args.heap_min_free);
                builder.add_heap_free(args.heap_free);
                builder.add_crash_count(args.crash_count);
                builder.add_fault_count(args.fault_count);
                builder.add_wifi_rssi(args.wifi_rssi);
                builder.finish()
            }

            #[inline]
            pub fn uptime_secs(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(DiagnosticsResponse::VT_UPTIME_SECS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn control_cycles(&self) -> u64 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u64>(DiagnosticsResponse::VT_CONTROL_CYCLES, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn fault_count(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DiagnosticsResponse::VT_FAULT_COUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn crash_count(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DiagnosticsResponse::VT_CRASH_COUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn heap_free(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DiagnosticsResponse::VT_HEAP_FREE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn heap_min_free(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DiagnosticsResponse::VT_HEAP_MIN_FREE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn wifi_rssi(&self) -> i8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i8>(DiagnosticsResponse::VT_WIFI_RSSI, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn nvs_free_entries(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DiagnosticsResponse::VT_NVS_FREE_ENTRIES, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn ulp_wake_count(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<u32>(DiagnosticsResponse::VT_ULP_WAKE_COUNT, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn crash_entries(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CrashEntryFbs<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CrashEntryFbs>>,
                    >>(DiagnosticsResponse::VT_CRASH_ENTRIES, None)
                }
            }
        }

        impl flatbuffers::Verifiable for DiagnosticsResponse<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u64>("uptime_secs", Self::VT_UPTIME_SECS, false)?
                    .visit_field::<u64>("control_cycles", Self::VT_CONTROL_CYCLES, false)?
                    .visit_field::<u32>("fault_count", Self::VT_FAULT_COUNT, false)?
                    .visit_field::<u32>("crash_count", Self::VT_CRASH_COUNT, false)?
                    .visit_field::<u32>("heap_free", Self::VT_HEAP_FREE, false)?
                    .visit_field::<u32>("heap_min_free", Self::VT_HEAP_MIN_FREE, false)?
                    .visit_field::<i8>("wifi_rssi", Self::VT_WIFI_RSSI, false)?
                    .visit_field::<u32>("nvs_free_entries", Self::VT_NVS_FREE_ENTRIES, false)?
                    .visit_field::<u32>("ulp_wake_count", Self::VT_ULP_WAKE_COUNT, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CrashEntryFbs>>,
                    >>("crash_entries", Self::VT_CRASH_ENTRIES, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DiagnosticsResponseArgs<'a> {
            pub uptime_secs: u64,
            pub control_cycles: u64,
            pub fault_count: u32,
            pub crash_count: u32,
            pub heap_free: u32,
            pub heap_min_free: u32,
            pub wifi_rssi: i8,
            pub nvs_free_entries: u32,
            pub ulp_wake_count: u32,
            pub crash_entries: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CrashEntryFbs<'a>>>,
                >,
            >,
        }
        impl<'a> Default for DiagnosticsResponseArgs<'a> {
            #[inline]
            fn default() -> Self {
                DiagnosticsResponseArgs {
                    uptime_secs: 0,
                    control_cycles: 0,
                    fault_count: 0,
                    crash_count: 0,
                    heap_free: 0,
                    heap_min_free: 0,
                    wifi_rssi: 0,
                    nvs_free_entries: 0,
                    ulp_wake_count: 0,
                    crash_entries: None,
                }
            }
        }

        pub struct DiagnosticsResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DiagnosticsResponseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_uptime_secs(&mut self, uptime_secs: u64) {
                self.fbb_
                    .push_slot::<u64>(DiagnosticsResponse::VT_UPTIME_SECS, uptime_secs, 0);
            }
            #[inline]
            pub fn add_control_cycles(&mut self, control_cycles: u64) {
                self.fbb_.push_slot::<u64>(
                    DiagnosticsResponse::VT_CONTROL_CYCLES,
                    control_cycles,
                    0,
                );
            }
            #[inline]
            pub fn add_fault_count(&mut self, fault_count: u32) {
                self.fbb_
                    .push_slot::<u32>(DiagnosticsResponse::VT_FAULT_COUNT, fault_count, 0);
            }
            #[inline]
            pub fn add_crash_count(&mut self, crash_count: u32) {
                self.fbb_
                    .push_slot::<u32>(DiagnosticsResponse::VT_CRASH_COUNT, crash_count, 0);
            }
            #[inline]
            pub fn add_heap_free(&mut self, heap_free: u32) {
                self.fbb_
                    .push_slot::<u32>(DiagnosticsResponse::VT_HEAP_FREE, heap_free, 0);
            }
            #[inline]
            pub fn add_heap_min_free(&mut self, heap_min_free: u32) {
                self.fbb_
                    .push_slot::<u32>(DiagnosticsResponse::VT_HEAP_MIN_FREE, heap_min_free, 0);
            }
            #[inline]
            pub fn add_wifi_rssi(&mut self, wifi_rssi: i8) {
                self.fbb_
                    .push_slot::<i8>(DiagnosticsResponse::VT_WIFI_RSSI, wifi_rssi, 0);
            }
            #[inline]
            pub fn add_nvs_free_entries(&mut self, nvs_free_entries: u32) {
                self.fbb_.push_slot::<u32>(
                    DiagnosticsResponse::VT_NVS_FREE_ENTRIES,
                    nvs_free_entries,
                    0,
                );
            }
            #[inline]
            pub fn add_ulp_wake_count(&mut self, ulp_wake_count: u32) {
                self.fbb_.push_slot::<u32>(
                    DiagnosticsResponse::VT_ULP_WAKE_COUNT,
                    ulp_wake_count,
                    0,
                );
            }
            #[inline]
            pub fn add_crash_entries(
                &mut self,
                crash_entries: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CrashEntryFbs<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DiagnosticsResponse::VT_CRASH_ENTRIES,
                    crash_entries,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DiagnosticsResponseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DiagnosticsResponseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DiagnosticsResponse<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DiagnosticsResponse<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DiagnosticsResponse");
                ds.field("uptime_secs", &self.uptime_secs());
                ds.field("control_cycles", &self.control_cycles());
                ds.field("fault_count", &self.fault_count());
                ds.field("crash_count", &self.crash_count());
                ds.field("heap_free", &self.heap_free());
                ds.field("heap_min_free", &self.heap_min_free());
                ds.field("wifi_rssi", &self.wifi_rssi());
                ds.field("nvs_free_entries", &self.nvs_free_entries());
                ds.field("ulp_wake_count", &self.ulp_wake_count());
                ds.field("crash_entries", &self.crash_entries());
                ds.finish()
            }
        }
        pub enum MessageOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Message<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Message<'a> {
            type Inner = Message<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Message<'a> {
            pub const VT_ID: flatbuffers::VOffsetT = 4;
            pub const VT_PAYLOAD_TYPE: flatbuffers::VOffsetT = 6;
            pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Message { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args MessageArgs,
            ) -> flatbuffers::WIPOffset<Message<'bldr>> {
                let mut builder = MessageBuilder::new(_fbb);
                if let Some(x) = args.payload {
                    builder.add_payload(x);
                }
                builder.add_id(args.id);
                builder.add_payload_type(args.payload_type);
                builder.finish()
            }

            /// Monotonically increasing message ID for request/response correlation.
            #[inline]
            pub fn id(&self) -> u32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u32>(Message::VT_ID, Some(0)).unwrap() }
            }
            #[inline]
            pub fn payload_type(&self) -> Payload {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Payload>(Message::VT_PAYLOAD_TYPE, Some(Payload::NONE))
                        .unwrap()
                }
            }
            #[inline]
            pub fn payload(&self) -> Option<flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            Message::VT_PAYLOAD,
                            None,
                        )
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_get_status_request(&self) -> Option<GetStatusRequest<'a>> {
                if self.payload_type() == Payload::GetStatusRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { GetStatusRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_start_scrub_request(&self) -> Option<StartScrubRequest<'a>> {
                if self.payload_type() == Payload::StartScrubRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { StartScrubRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_stop_scrub_request(&self) -> Option<StopScrubRequest<'a>> {
                if self.payload_type() == Payload::StopScrubRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { StopScrubRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_clear_faults_request(&self) -> Option<ClearFaultsRequest<'a>> {
                if self.payload_type() == Payload::ClearFaultsRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { ClearFaultsRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_set_config_request(&self) -> Option<SetConfigRequest<'a>> {
                if self.payload_type() == Payload::SetConfigRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { SetConfigRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_set_schedule_request(&self) -> Option<SetScheduleRequest<'a>> {
                if self.payload_type() == Payload::SetScheduleRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { SetScheduleRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_cancel_schedule_request(&self) -> Option<CancelScheduleRequest<'a>> {
                if self.payload_type() == Payload::CancelScheduleRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { CancelScheduleRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_subscribe_telemetry_request(
                &self,
            ) -> Option<SubscribeTelemetryRequest<'a>> {
                if self.payload_type() == Payload::SubscribeTelemetryRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { SubscribeTelemetryRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_unsubscribe_telemetry_request(
                &self,
            ) -> Option<UnsubscribeTelemetryRequest<'a>> {
                if self.payload_type() == Payload::UnsubscribeTelemetryRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { UnsubscribeTelemetryRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_get_device_info_request(&self) -> Option<GetDeviceInfoRequest<'a>> {
                if self.payload_type() == Payload::GetDeviceInfoRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { GetDeviceInfoRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_status_response(&self) -> Option<StatusResponse<'a>> {
                if self.payload_type() == Payload::StatusResponse {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { StatusResponse::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_device_info_response(&self) -> Option<DeviceInfoResponse<'a>> {
                if self.payload_type() == Payload::DeviceInfoResponse {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { DeviceInfoResponse::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_ack_response(&self) -> Option<AckResponse<'a>> {
                if self.payload_type() == Payload::AckResponse {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { AckResponse::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_telemetry_frame(&self) -> Option<TelemetryFrame<'a>> {
                if self.payload_type() == Payload::TelemetryFrame {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { TelemetryFrame::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_state_change_event(&self) -> Option<StateChangeEvent<'a>> {
                if self.payload_type() == Payload::StateChangeEvent {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { StateChangeEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_fault_event(&self) -> Option<FaultEvent<'a>> {
                if self.payload_type() == Payload::FaultEvent {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { FaultEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_auth_challenge_request(&self) -> Option<AuthChallengeRequest<'a>> {
                if self.payload_type() == Payload::AuthChallengeRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { AuthChallengeRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_auth_challenge_response(&self) -> Option<AuthChallengeResponse<'a>> {
                if self.payload_type() == Payload::AuthChallengeResponse {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { AuthChallengeResponse::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_auth_verify_request(&self) -> Option<AuthVerifyRequest<'a>> {
                if self.payload_type() == Payload::AuthVerifyRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { AuthVerifyRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_auth_verify_response(&self) -> Option<AuthVerifyResponse<'a>> {
                if self.payload_type() == Payload::AuthVerifyResponse {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { AuthVerifyResponse::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_provision_cert_request(&self) -> Option<ProvisionCertRequest<'a>> {
                if self.payload_type() == Payload::ProvisionCertRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { ProvisionCertRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_get_cert_status_request(&self) -> Option<GetCertStatusRequest<'a>> {
                if self.payload_type() == Payload::GetCertStatusRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { GetCertStatusRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_cert_status_response(&self) -> Option<CertStatusResponse<'a>> {
                if self.payload_type() == Payload::CertStatusResponse {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { CertStatusResponse::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_ota_begin_request(&self) -> Option<OtaBeginRequest<'a>> {
                if self.payload_type() == Payload::OtaBeginRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { OtaBeginRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_ota_chunk_request(&self) -> Option<OtaChunkRequest<'a>> {
                if self.payload_type() == Payload::OtaChunkRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { OtaChunkRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_ota_finalize_request(&self) -> Option<OtaFinalizeRequest<'a>> {
                if self.payload_type() == Payload::OtaFinalizeRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { OtaFinalizeRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_ota_response(&self) -> Option<OtaResponse<'a>> {
                if self.payload_type() == Payload::OtaResponse {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { OtaResponse::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_ota_progress_event(&self) -> Option<OtaProgressEvent<'a>> {
                if self.payload_type() == Payload::OtaProgressEvent {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { OtaProgressEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_get_diagnostics_request(&self) -> Option<GetDiagnosticsRequest<'a>> {
                if self.payload_type() == Payload::GetDiagnosticsRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { GetDiagnosticsRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_clear_diagnostics_request(
                &self,
            ) -> Option<ClearDiagnosticsRequest<'a>> {
                if self.payload_type() == Payload::ClearDiagnosticsRequest {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { ClearDiagnosticsRequest::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn payload_as_diagnostics_response(&self) -> Option<DiagnosticsResponse<'a>> {
                if self.payload_type() == Payload::DiagnosticsResponse {
                    self.payload().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { DiagnosticsResponse::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for Message<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_field::<u32>("id", Self::VT_ID, false)?
     .visit_union::<Payload, _>("payload_type", Self::VT_PAYLOAD_TYPE, "payload", Self::VT_PAYLOAD, false, |key, v, pos| {
        match key {
          Payload::GetStatusRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetStatusRequest>>("Payload::GetStatusRequest", pos),
          Payload::StartScrubRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StartScrubRequest>>("Payload::StartScrubRequest", pos),
          Payload::StopScrubRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StopScrubRequest>>("Payload::StopScrubRequest", pos),
          Payload::ClearFaultsRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ClearFaultsRequest>>("Payload::ClearFaultsRequest", pos),
          Payload::SetConfigRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SetConfigRequest>>("Payload::SetConfigRequest", pos),
          Payload::SetScheduleRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SetScheduleRequest>>("Payload::SetScheduleRequest", pos),
          Payload::CancelScheduleRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CancelScheduleRequest>>("Payload::CancelScheduleRequest", pos),
          Payload::SubscribeTelemetryRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SubscribeTelemetryRequest>>("Payload::SubscribeTelemetryRequest", pos),
          Payload::UnsubscribeTelemetryRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnsubscribeTelemetryRequest>>("Payload::UnsubscribeTelemetryRequest", pos),
          Payload::GetDeviceInfoRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetDeviceInfoRequest>>("Payload::GetDeviceInfoRequest", pos),
          Payload::StatusResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StatusResponse>>("Payload::StatusResponse", pos),
          Payload::DeviceInfoResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DeviceInfoResponse>>("Payload::DeviceInfoResponse", pos),
          Payload::AckResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AckResponse>>("Payload::AckResponse", pos),
          Payload::TelemetryFrame => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TelemetryFrame>>("Payload::TelemetryFrame", pos),
          Payload::StateChangeEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StateChangeEvent>>("Payload::StateChangeEvent", pos),
          Payload::FaultEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FaultEvent>>("Payload::FaultEvent", pos),
          Payload::AuthChallengeRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthChallengeRequest>>("Payload::AuthChallengeRequest", pos),
          Payload::AuthChallengeResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthChallengeResponse>>("Payload::AuthChallengeResponse", pos),
          Payload::AuthVerifyRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthVerifyRequest>>("Payload::AuthVerifyRequest", pos),
          Payload::AuthVerifyResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthVerifyResponse>>("Payload::AuthVerifyResponse", pos),
          Payload::ProvisionCertRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ProvisionCertRequest>>("Payload::ProvisionCertRequest", pos),
          Payload::GetCertStatusRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetCertStatusRequest>>("Payload::GetCertStatusRequest", pos),
          Payload::CertStatusResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CertStatusResponse>>("Payload::CertStatusResponse", pos),
          Payload::OtaBeginRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OtaBeginRequest>>("Payload::OtaBeginRequest", pos),
          Payload::OtaChunkRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OtaChunkRequest>>("Payload::OtaChunkRequest", pos),
          Payload::OtaFinalizeRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OtaFinalizeRequest>>("Payload::OtaFinalizeRequest", pos),
          Payload::OtaResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OtaResponse>>("Payload::OtaResponse", pos),
          Payload::OtaProgressEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OtaProgressEvent>>("Payload::OtaProgressEvent", pos),
          Payload::GetDiagnosticsRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GetDiagnosticsRequest>>("Payload::GetDiagnosticsRequest", pos),
          Payload::ClearDiagnosticsRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ClearDiagnosticsRequest>>("Payload::ClearDiagnosticsRequest", pos),
          Payload::DiagnosticsResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DiagnosticsResponse>>("Payload::DiagnosticsResponse", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct MessageArgs {
            pub id: u32,
            pub payload_type: Payload,
            pub payload: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for MessageArgs {
            #[inline]
            fn default() -> Self {
                MessageArgs {
                    id: 0,
                    payload_type: Payload::NONE,
                    payload: None,
                }
            }
        }

        pub struct MessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_id(&mut self, id: u32) {
                self.fbb_.push_slot::<u32>(Message::VT_ID, id, 0);
            }
            #[inline]
            pub fn add_payload_type(&mut self, payload_type: Payload) {
                self.fbb_.push_slot::<Payload>(
                    Message::VT_PAYLOAD_TYPE,
                    payload_type,
                    Payload::NONE,
                );
            }
            #[inline]
            pub fn add_payload(
                &mut self,
                payload: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_PAYLOAD, payload);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> MessageBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                MessageBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Message<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Message");
                ds.field("id", &self.id());
                ds.field("payload_type", &self.payload_type());
                match self.payload_type() {
                    Payload::GetStatusRequest => {
                        if let Some(x) = self.payload_as_get_status_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::StartScrubRequest => {
                        if let Some(x) = self.payload_as_start_scrub_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::StopScrubRequest => {
                        if let Some(x) = self.payload_as_stop_scrub_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::ClearFaultsRequest => {
                        if let Some(x) = self.payload_as_clear_faults_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::SetConfigRequest => {
                        if let Some(x) = self.payload_as_set_config_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::SetScheduleRequest => {
                        if let Some(x) = self.payload_as_set_schedule_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::CancelScheduleRequest => {
                        if let Some(x) = self.payload_as_cancel_schedule_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::SubscribeTelemetryRequest => {
                        if let Some(x) = self.payload_as_subscribe_telemetry_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::UnsubscribeTelemetryRequest => {
                        if let Some(x) = self.payload_as_unsubscribe_telemetry_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::GetDeviceInfoRequest => {
                        if let Some(x) = self.payload_as_get_device_info_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::StatusResponse => {
                        if let Some(x) = self.payload_as_status_response() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::DeviceInfoResponse => {
                        if let Some(x) = self.payload_as_device_info_response() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::AckResponse => {
                        if let Some(x) = self.payload_as_ack_response() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::TelemetryFrame => {
                        if let Some(x) = self.payload_as_telemetry_frame() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::StateChangeEvent => {
                        if let Some(x) = self.payload_as_state_change_event() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::FaultEvent => {
                        if let Some(x) = self.payload_as_fault_event() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::AuthChallengeRequest => {
                        if let Some(x) = self.payload_as_auth_challenge_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::AuthChallengeResponse => {
                        if let Some(x) = self.payload_as_auth_challenge_response() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::AuthVerifyRequest => {
                        if let Some(x) = self.payload_as_auth_verify_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::AuthVerifyResponse => {
                        if let Some(x) = self.payload_as_auth_verify_response() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::ProvisionCertRequest => {
                        if let Some(x) = self.payload_as_provision_cert_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::GetCertStatusRequest => {
                        if let Some(x) = self.payload_as_get_cert_status_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::CertStatusResponse => {
                        if let Some(x) = self.payload_as_cert_status_response() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::OtaBeginRequest => {
                        if let Some(x) = self.payload_as_ota_begin_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::OtaChunkRequest => {
                        if let Some(x) = self.payload_as_ota_chunk_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::OtaFinalizeRequest => {
                        if let Some(x) = self.payload_as_ota_finalize_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::OtaResponse => {
                        if let Some(x) = self.payload_as_ota_response() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::OtaProgressEvent => {
                        if let Some(x) = self.payload_as_ota_progress_event() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::GetDiagnosticsRequest => {
                        if let Some(x) = self.payload_as_get_diagnostics_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::ClearDiagnosticsRequest => {
                        if let Some(x) = self.payload_as_clear_diagnostics_request() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    Payload::DiagnosticsResponse => {
                        if let Some(x) = self.payload_as_diagnostics_response() {
                            ds.field("payload", &x)
                        } else {
                            ds.field(
                                "payload",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("payload", &x)
                    }
                };
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `Message`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_message_unchecked`.
        pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<Message>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `Message` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_message_unchecked`.
        pub fn size_prefixed_root_as_message(
            buf: &[u8],
        ) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<Message>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `Message` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_message_unchecked`.
        pub fn root_as_message_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `Message` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_message_unchecked`.
        pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `Message`.
        pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
            flatbuffers::root_unchecked::<Message>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
        pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
            flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
        }
        #[inline]
        pub fn finish_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<Message<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
            root: flatbuffers::WIPOffset<Message<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod rpc
} // pub mod petfilter
