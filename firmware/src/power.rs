//! Power management and sleep/wake lifecycle.
//!
//! The ESP32-S3 supports multiple power modes:
//!
//! ```text
//! ┌────────────────────────────────────────────────────────────┐
//! │                   Power State Machine                      │
//! │                                                            │
//! │  ┌──────┐  idle timeout   ┌───────────┐  deeper timeout    │
//! │  │Active├────────────────▶│Light Sleep├────────────────▶   │
//! │  │ ~80mA│                 │  ~2mA     │                    │
//! │  └──┬───┘                 └─────┬─────┘                    │
//! │     │                           │                          │
//! │     │  NH3/timer/               │  NH3/timer/              │
//! │     │  comms event              │  GPIO wake               │
//! │     │                           │                          │
//! │     ▼                           ▼                          │
//! │  ┌──────┐  extended idle  ┌──────────┐                     │
//! │  │Active│◀────────────────│Deep Sleep│                     │
//! │  │      │  ULP wake       │  ~34µA   │                     │
//! │  └──────┘                 │  ULP ADC │                     │
//! │                           │  ~416µA  │                     │
//! │                           └──────────┘                     │
//! └────────────────────────────────────────────────────────────┘
//! ```
//!
//! The ULP coprocessor monitors the NH3 sensor during deep sleep
//! and wakes the main CPU when the threshold is exceeded.
//!
//! ## Dual-target design
//!
//! This module compiles for two targets:
//!
//! - **`target_os = "espidf"`** — real hardware path using `esp_idf_sys` FFI
//!   to program the ULP RISC-V coprocessor, write RTC slow-memory variables,
//!   and invoke the ESP-IDF sleep APIs.
//! - **`not(target_os = "espidf")`** — simulation path for host-side testing.
//!   ULP state is tracked in-struct, light sleep is emulated with
//!   `std::thread::sleep`, and deep sleep panics (since the CPU would reset
//!   on real hardware and `main()` re-enters).

use crate::config::SystemConfig;
use log::info;

// ── Error type ────────────────────────────────────────────────

/// Errors that can occur in the power management subsystem.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PowerError {
    /// `ulp_riscv_load_binary()` returned a non-OK error code.
    UlpLoadFailed(i32),
    /// `ulp_riscv_run()` returned a non-OK error code.
    UlpStartFailed(i32),
}

impl core::fmt::Display for PowerError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::UlpLoadFailed(rc) => write!(f, "ULP binary load failed (rc={})", rc),
            Self::UlpStartFailed(rc) => write!(f, "ULP run failed (rc={})", rc),
        }
    }
}

// ── ULP shared variable bindings ──────────────────────────────

/// Shared state between main CPU and ULP coprocessor.
///
/// On ESP-IDF these fields mirror the `volatile uint32_t ulp_*` symbols
/// generated by the ULP toolchain and located in RTC slow memory.
/// On non-ESP targets the struct is a plain in-memory simulation.
#[derive(Debug, Clone)]
pub struct UlpSharedState {
    /// ADC threshold for wake (set by main CPU).
    pub nh3_threshold_adc: u32,
    /// Latest ADC reading from ULP.
    pub nh3_last_reading: u32,
    /// Consecutive above-threshold count.
    pub nh3_above_count: u32,
    /// Required consecutive readings before wake.
    pub nh3_confirm_count: u32,
    /// ULP cycle counter.
    pub cycle_count: u32,
    /// Stop flag (main CPU → ULP).
    pub stop_flag: u32,
}

impl Default for UlpSharedState {
    fn default() -> Self {
        Self {
            nh3_threshold_adc: 500,
            nh3_last_reading: 0,
            nh3_above_count: 0,
            nh3_confirm_count: 3,
            cycle_count: 0,
            stop_flag: 0,
        }
    }
}

// ── ULP extern symbols (ESP-IDF only) ─────────────────────────

// SAFETY: These extern statics are located in RTC slow memory (shared with
// the ULP coprocessor). All accesses in this module occur only after calling
// stop_ulp_monitor() — which sets ulp_ulp_stop_flag and waits for the ULP to
// halt — ensuring the main CPU holds exclusive access to the shared region.
// The ULP never writes to threshold/confirm fields; the main CPU never writes
// to last_reading/above_count/cycle_count while the ULP is running.
#[cfg(target_os = "espidf")]
unsafe extern "C" {
    static mut ulp_main: u32;
    static mut ulp_ulp_nh3_threshold_adc: u32;
    static mut ulp_ulp_nh3_last_reading: u32;
    static mut ulp_ulp_nh3_above_count: u32;
    static mut ulp_ulp_nh3_confirm_count: u32;
    static mut ulp_ulp_cycle_count: u32;
    static mut ulp_ulp_stop_flag: u32;
}

// ── ULP variable accessors (ESP-IDF only) ────────────────────
//
// Each accessor documents the invariant that allows its use.
// All writes occur before ulp_riscv_run() or after stop_ulp_monitor(),
// so the main CPU and ULP never write the same field concurrently.

/// Read the last NH3 ADC reading captured by the ULP.
/// SAFETY: Called only after stop_ulp_monitor(); ULP is halted.
#[cfg(target_os = "espidf")]
unsafe fn ulp_read_nh3_last() -> u32 {
    unsafe { ulp_ulp_nh3_last_reading }
}

/// Read the consecutive above-threshold count from the ULP.
/// SAFETY: Same as `ulp_read_nh3_last()`.
#[cfg(target_os = "espidf")]
unsafe fn ulp_read_above_count() -> u32 {
    unsafe { ulp_ulp_nh3_above_count }
}

/// Read the ULP cycle counter.
/// SAFETY: Same as `ulp_read_nh3_last()`.
#[cfg(target_os = "espidf")]
unsafe fn ulp_read_cycle_count() -> u32 {
    unsafe { ulp_ulp_cycle_count }
}

/// Write the NH3 ADC threshold that triggers a ULP wake.
/// SAFETY: Called before ulp_riscv_run(); ULP has not started yet.
#[cfg(target_os = "espidf")]
unsafe fn ulp_write_threshold(val: u32) {
    unsafe {
        ulp_ulp_nh3_threshold_adc = val;
    }
}

/// Write the consecutive-readings confirm count.
/// SAFETY: Same as `ulp_write_threshold()`.
#[cfg(target_os = "espidf")]
unsafe fn ulp_write_confirm_count(val: u32) {
    unsafe {
        ulp_ulp_nh3_confirm_count = val;
    }
}

/// Set the stop flag to signal the ULP to halt.
/// SAFETY: Written before reading shared fields; read by ULP in its loop.
#[cfg(target_os = "espidf")]
unsafe fn ulp_write_stop_flag(val: u32) {
    unsafe {
        ulp_ulp_stop_flag = val;
    }
}

// ── Power modes ───────────────────────────────────────────────

/// System power mode.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PowerMode {
    /// Full speed: all peripherals active, WiFi/BLE available.
    Active,
    /// CPU frequency reduced, peripherals active, WiFi suspended.
    LowPower,
    /// CPU halted, RTC + ULP running. GPIO/timer/ULP can wake.
    LightSleep,
    /// Main CPU off, only RTC + ULP. ULP ADC monitors NH3.
    DeepSleep,
}

/// Wake reason after returning from sleep.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WakeReason {
    /// First boot (not a wake from sleep).
    PowerOn,
    /// ULP coprocessor triggered wake (NH3 above threshold).
    UlpWake,
    /// Hardware timer expired.
    Timer,
    /// GPIO pin change (e.g. button press, external interrupt).
    Gpio,
    /// Touchpad (not used, but ESP32-S3 supports it).
    Touchpad,
    /// Unknown or unsupported wake source.
    Unknown,
}

// ── Power manager ─────────────────────────────────────────────

/// Manages power state transitions and ULP lifecycle.
pub struct PowerManager {
    mode: PowerMode,
    ulp_state: UlpSharedState,
    /// Seconds of idle before transitioning to light sleep.
    idle_to_light_secs: u32,
    /// Seconds of idle before transitioning to deep sleep.
    idle_to_deep_secs: u32,
    /// Ticks since last meaningful activity (NH3 event, user interaction).
    idle_ticks: u64,
    /// Whether ULP program has been loaded into RTC memory.
    ulp_loaded: bool,
}

impl PowerManager {
    pub fn new(_config: &SystemConfig) -> Self {
        Self {
            mode: PowerMode::Active,
            ulp_state: UlpSharedState::default(),
            idle_to_light_secs: 300, // 5 minutes
            idle_to_deep_secs: 1800, // 30 minutes
            idle_ticks: 0,
            ulp_loaded: false,
        }
    }

    // ── Wake reason ───────────────────────────────────────────

    /// Determine the wake reason on startup by querying the ESP-IDF
    /// sleep wakeup cause register.
    #[cfg(target_os = "espidf")]
    pub fn determine_wake_reason(&self) -> WakeReason {
        use esp_idf_sys::*;

        match unsafe { esp_sleep_get_wakeup_cause() } {
            esp_sleep_source_t_ESP_SLEEP_WAKEUP_ULP => WakeReason::UlpWake,
            esp_sleep_source_t_ESP_SLEEP_WAKEUP_TIMER => WakeReason::Timer,
            esp_sleep_source_t_ESP_SLEEP_WAKEUP_GPIO => WakeReason::Gpio,
            esp_sleep_source_t_ESP_SLEEP_WAKEUP_TOUCHPAD => WakeReason::Touchpad,
            esp_sleep_source_t_ESP_SLEEP_WAKEUP_UNDEFINED => WakeReason::PowerOn,
            _ => WakeReason::Unknown,
        }
    }

    /// Determine the wake reason on startup.
    ///
    /// Simulation always returns [`WakeReason::PowerOn`].
    #[cfg(not(target_os = "espidf"))]
    pub fn determine_wake_reason(&self) -> WakeReason {
        WakeReason::PowerOn
    }

    // ── ULP program loading ───────────────────────────────────

    /// Mark the ULP monitor as available.
    ///
    /// The ULP component is built and linked by ESP-IDF during firmware build,
    /// so runtime only tracks the loaded state here.
    #[cfg(target_os = "espidf")]
    pub fn load_ulp_program(&mut self) -> Result<(), PowerError> {
        if self.ulp_loaded {
            return Ok(());
        }

        info!("ULP NH3 monitor linked and ready");
        self.ulp_loaded = true;
        Ok(())
    }

    /// Load the ULP program into RTC slow memory.
    /// Call once during startup.
    ///
    /// Simulation records the loaded flag without touching hardware.
    #[cfg(not(target_os = "espidf"))]
    pub fn load_ulp_program(&mut self) -> Result<(), PowerError> {
        if self.ulp_loaded {
            return Ok(());
        }

        info!("Loading ULP NH3 monitor program (simulated)");
        self.ulp_loaded = true;
        Ok(())
    }

    // ── ULP monitor start ─────────────────────────────────────

    /// Write threshold parameters to RTC slow memory and launch the
    /// ULP RISC-V coprocessor.
    #[cfg(target_os = "espidf")]
    pub fn start_ulp_monitor(&mut self, threshold_adc: u32, confirm_count: u32) {
        self.ulp_state.nh3_threshold_adc = threshold_adc;
        self.ulp_state.nh3_confirm_count = confirm_count;
        self.ulp_state.stop_flag = 0;

        unsafe {
            ulp_write_threshold(threshold_adc);
            ulp_write_confirm_count(confirm_count);
            ulp_write_stop_flag(0);
            esp_idf_sys::ulp_riscv_run();
        }

        info!(
            "ULP NH3 monitor started: threshold_adc={}, confirm={}",
            threshold_adc, confirm_count
        );
    }

    /// Configure ULP threshold from current config and start ULP.
    ///
    /// Simulation records the state in-struct without hardware access.
    #[cfg(not(target_os = "espidf"))]
    pub fn start_ulp_monitor(&mut self, threshold_adc: u32, confirm_count: u32) {
        self.ulp_state.nh3_threshold_adc = threshold_adc;
        self.ulp_state.nh3_confirm_count = confirm_count;
        self.ulp_state.stop_flag = 0;

        info!(
            "ULP NH3 monitor started (simulated): threshold_adc={}, confirm={}",
            threshold_adc, confirm_count
        );
    }

    // ── ULP monitor stop ──────────────────────────────────────

    /// Signal the ULP to stop by setting the RTC slow-memory stop flag.
    /// Call before the main CPU takes over ADC sampling.
    #[cfg(target_os = "espidf")]
    pub fn stop_ulp_monitor(&mut self) {
        self.ulp_state.stop_flag = 1;

        unsafe {
            ulp_write_stop_flag(1);
        }

        info!("ULP NH3 monitor stop requested");
    }

    /// Stop the ULP monitor (call before main CPU takes over ADC).
    ///
    /// Simulation sets the flag in-struct only.
    #[cfg(not(target_os = "espidf"))]
    pub fn stop_ulp_monitor(&mut self) {
        self.ulp_state.stop_flag = 1;
        info!("ULP NH3 monitor stop requested (simulated)");
    }

    // ── ULP state readback ────────────────────────────────────

    /// Read ULP diagnostic counters from RTC slow memory after wake.
    #[cfg(target_os = "espidf")]
    pub fn read_ulp_state(&mut self) -> &UlpSharedState {
        unsafe {
            self.ulp_state.nh3_last_reading = ulp_read_nh3_last();
            self.ulp_state.nh3_above_count = ulp_read_above_count();
            self.ulp_state.cycle_count = ulp_read_cycle_count();
        }

        &self.ulp_state
    }

    /// Read ULP diagnostic data after wake.
    ///
    /// Simulation returns the in-struct state unchanged.
    #[cfg(not(target_os = "espidf"))]
    pub fn read_ulp_state(&mut self) -> &UlpSharedState {
        &self.ulp_state
    }

    // ── Light sleep ───────────────────────────────────────────

    /// Enter light sleep with timer + GPIO wakeup sources enabled.
    /// Returns the wake reason when the CPU resumes.
    #[cfg(target_os = "espidf")]
    pub fn enter_light_sleep(&mut self, timeout_secs: u32) -> WakeReason {
        info!("Entering light sleep (timeout={}s)", timeout_secs);
        self.mode = PowerMode::LightSleep;

        unsafe {
            esp_idf_sys::esp_sleep_enable_timer_wakeup(timeout_secs as u64 * 1_000_000);
            esp_idf_sys::esp_sleep_enable_gpio_wakeup();
            esp_idf_sys::esp_light_sleep_start();
        }

        self.mode = PowerMode::Active;
        self.determine_wake_reason()
    }

    /// Enter light sleep mode.
    /// Returns the wake reason when the CPU resumes.
    ///
    /// Simulation sleeps the host thread for `timeout_secs` then returns
    /// [`WakeReason::PowerOn`].
    #[cfg(not(target_os = "espidf"))]
    pub fn enter_light_sleep(&mut self, timeout_secs: u32) -> WakeReason {
        use crate::events::{Event, push_event};
        info!(
            "PowerManager(sim): light sleep {}s → injecting UlpWake after 100ms",
            timeout_secs
        );
        self.mode = PowerMode::LightSleep;

        // Keep sim sleep short (100ms) so tests run fast; real hardware
        // sleeps for the full timeout_secs duration.
        std::thread::sleep(std::time::Duration::from_millis(100));

        // Inject a UlpWake event to exercise the wake-path event handler,
        // mirroring real hardware behaviour where the ULP fires after sleep.
        push_event(Event::UlpWake);
        self.mode = PowerMode::Active;
        WakeReason::UlpWake
    }

    // ── Deep sleep ────────────────────────────────────────────

    /// Enter deep sleep with ULP + timer wakeup sources. Starts the
    /// ULP NH3 monitor before sleeping. This function does **not**
    /// return — the CPU resets on wake.
    #[cfg(target_os = "espidf")]
    #[allow(unreachable_code)]
    pub fn enter_deep_sleep(&mut self, nh3_threshold_adc: u32) -> ! {
        info!("Entering deep sleep with ULP NH3 monitor");
        self.mode = PowerMode::DeepSleep;

        self.start_ulp_monitor(nh3_threshold_adc, 3);

        unsafe {
            esp_idf_sys::esp_sleep_enable_ulp_wakeup();
            esp_idf_sys::esp_sleep_enable_timer_wakeup(self.idle_to_deep_secs as u64 * 1_000_000);
            esp_idf_sys::esp_deep_sleep_start();
        }

    }

    /// Enter deep sleep mode with ULP monitoring.
    /// This function does **not** return — the CPU resets on wake.
    ///
    /// Simulation panics because on real hardware the CPU would reset
    /// and `main()` re-enters with a new wake reason.
    #[cfg(not(target_os = "espidf"))]
    pub fn enter_deep_sleep(&mut self, nh3_threshold_adc: u32) -> ! {
        info!("Entering deep sleep (simulated) with ULP NH3 monitor");
        self.mode = PowerMode::DeepSleep;

        self.start_ulp_monitor(nh3_threshold_adc, 3);

        panic!("deep_sleep: simulation — restart to continue");
    }

    // ── Idle tick / power transition suggestions ──────────────

    /// Called each tick to track idle time and suggest power transitions.
    pub fn tick(&mut self, activity: bool) -> Option<PowerMode> {
        if activity {
            self.idle_ticks = 0;
            if self.mode != PowerMode::Active {
                self.mode = PowerMode::Active;
            }
            return None;
        }

        self.idle_ticks += 1;
        let idle_secs = self.idle_ticks; // At 1Hz tick rate, ticks ≈ seconds.

        if idle_secs >= self.idle_to_deep_secs as u64 && self.mode != PowerMode::DeepSleep {
            return Some(PowerMode::DeepSleep);
        }

        if idle_secs >= self.idle_to_light_secs as u64 && self.mode == PowerMode::Active {
            return Some(PowerMode::LightSleep);
        }

        None
    }

    pub fn mode(&self) -> PowerMode {
        self.mode
    }

    pub fn is_ulp_loaded(&self) -> bool {
        self.ulp_loaded
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::SystemConfig;

    fn make_pm() -> PowerManager {
        PowerManager::new(&SystemConfig::default())
    }

    #[test]
    fn starts_in_active_mode() {
        let pm = make_pm();
        assert_eq!(pm.mode(), PowerMode::Active);
    }

    #[test]
    fn ulp_not_loaded_initially() {
        let pm = make_pm();
        assert!(!pm.is_ulp_loaded());
    }

    #[test]
    fn activity_resets_idle() {
        let mut pm = make_pm();
        for _ in 0..100 {
            pm.tick(false);
        }
        assert!(pm.idle_ticks > 0);

        pm.tick(true);
        assert_eq!(pm.idle_ticks, 0);
    }

    #[test]
    fn no_transition_with_activity() {
        let mut pm = make_pm();
        for _ in 0..10000 {
            let result = pm.tick(true);
            assert!(result.is_none());
        }
        assert_eq!(pm.mode(), PowerMode::Active);
    }

    #[test]
    fn light_sleep_after_idle_threshold() {
        let mut pm = make_pm();
        let threshold = pm.idle_to_light_secs as u64;

        for i in 0..=threshold {
            let result = pm.tick(false);
            if i == threshold {
                assert_eq!(result, Some(PowerMode::LightSleep));
            }
        }
    }

    #[test]
    fn deep_sleep_after_extended_idle() {
        let mut pm = make_pm();
        let threshold = pm.idle_to_deep_secs as u64;

        for _ in 0..threshold {
            pm.tick(false);
        }
        let result = pm.tick(false);
        assert_eq!(result, Some(PowerMode::DeepSleep));
    }

    #[test]
    fn ulp_shared_state_exists() {
        let state = UlpSharedState::default();
        // Verify struct is constructible and fields are accessible
        let _ = state.nh3_threshold_adc;
        let _ = state.nh3_last_reading;
    }

    #[test]
    fn sim_ulp_load_succeeds() {
        let mut pm = make_pm();
        assert!(pm.load_ulp_program().is_ok());
        assert!(pm.is_ulp_loaded());
    }

    #[test]
    fn sim_ulp_monitor_cycle() {
        let mut pm = make_pm();
        pm.load_ulp_program().unwrap();
        pm.start_ulp_monitor(2000, 5);
        let state = pm.read_ulp_state();
        assert_eq!(state.nh3_threshold_adc, 2000);
        pm.stop_ulp_monitor();
    }
}
