# PetFilter Firmware — Definitive Work Breakdown

> Generated from the Purbright legacy carry-forward matrix, filtered through
> the architecture constraint: **federated encrypted comms only, no webUI,
> no captive portal, no REST endpoints, no public endpoints outside RPC**.

## Architecture Constraint Summary

```text
┌───────────────────────────────────────────────────────────────────────┐
│                     Communication Model                               │
│                                                                       │
│   Mobile App ◄──TLS──► ESP32 (RPC over TCP/BLE)                       │
│                                                                       │
│   • ALL communication via FlatBuffers RPC                             │
│   • Transport-layer encryption (TLS 1.3 / BLE bonding)                │
│   • Mutual authentication (PSK or X.509)                              │
│   • No HTTP server, no REST, no MQTT, no captive portal               │
│   • mDNS for LAN peer discovery (service type only, no web)           │
│   • BLE for initial provisioning (WiFi creds + device pairing)        │
│   • OTA firmware updates through the encrypted RPC channel            │
│                                                                       │
│   Excluded: webUI, captive portal, REST endpoints, MQTT               │
└───────────────────────────────────────────────────────────────────────┘
```

---

## Priority Definitions

| Priority | Meaning | Criteria |
|----------|---------|----------|
| **P0** | Must have for first bench prototype | Device can't function without it |
| **P1** | Must have for beta firmware | Required for real-world testing |
| **P2** | Should have for production firmware | Required for shipping product |

---

## P0 — Core Functionality (Bench Prototype)

These block the first hardware test. Without them the firmware doesn't
talk to real peripherals or communicate with anything.

### P0-1: Wire ESP-IDF HAL Drivers

**What**: Complete the `#[cfg(target_os = "espidf")]` stubs across all
sensor and driver modules so real ADC/GPIO/PWM/LEDC calls execute on
hardware.

**Scope**: 6 files — `ammonia.rs`, `temperature.rs`, `water_level.rs`,
`pump.rs`, `uvc.rs`, `status_led.rs`

**Depends on**: Physical ESP32-S3 dev board on the bench.

**Acceptance criteria**:
- `AmmoniaSensor::read_adc()` returns real ADC1 readings from MQ-137
- `TemperatureSensor::read_adc()` returns real NTC thermistor readings
- `WaterLevelSensor::read_gpio_a/b()` reads real XKC-Y25 levels
- `PumpDriver::set_duty_hw/set_direction_hw` drives DRV8871 via LEDC + GPIO
- `UvcDriver::set_enable_hw/set_duty_hw` drives PT4115 via GPIO + LEDC
- `StatusLed::set_channel_hw` drives 3-channel RGB via LEDC
- All drivers pass a smoke test on the breadboard

---

### P0-2: Wire ESP-IDF NVS Storage

**What**: Complete the `#[cfg(target_arch = "xtensa")]` stubs in
`adapters/nvs.rs` so configuration persists across reboots.

**Scope**: `adapters/nvs.rs` — 6 method stubs

**Acceptance criteria**:
- `ConfigPort::load()` reads serialized `SystemConfig` from NVS partition
- `ConfigPort::save()` validates + writes config to NVS (atomic commit)
- `StoragePort::{read,write,delete,exists}` work with ESP-IDF NVS blob API
- Config survives power cycle
- Encrypted NVS partition used for credential storage namespace

---

### P0-3: Wire ESP-IDF Power/ULP

**What**: Complete the `#[cfg(target_os = "espidf")]` stubs in `power.rs`
so deep sleep, light sleep, and ULP ADC monitoring work on hardware.

**Scope**: `power.rs` — 7 method stubs

**Acceptance criteria**:
- `determine_wake_reason()` correctly reads `esp_sleep_get_wakeup_cause()`
- `load_ulp_program()` loads ULP binary from linked symbols into RTC memory
- `start/stop_ulp_monitor()` writes RTC slow memory and calls `ulp_riscv_run()`
- `enter_light_sleep()` configures timer + GPIO wakeup and sleeps
- `enter_deep_sleep()` configures ULP + timer wakeup and never returns
- Device wakes from deep sleep when NH3 exceeds ULP threshold
- Current draw in deep sleep matches expected ~34uA (+ ~416uA ULP active)

---

### P0-4: Wire ESP-IDF Timer Interrupts

**What**: Replace the `std::thread::sleep` simulation in `main.rs` event
loop with real ESP-IDF hardware timer interrupts (esp_timer or GPTimer).

**Scope**: `main.rs` — event loop, new `drivers/hw_timer.rs`

**Acceptance criteria**:
- `ControlTick` events generated by hardware timer ISR at 1 Hz
- `SensorReadTick` events generated at 10 Hz
- CPU executes WFI between interrupts (no busy-wait)
- Timer ISRs push events into the lock-free SPSC queue

---

### P0-5: Build System Verification

**What**: Verify the firmware cross-compiles for `xtensa-esp32s3-espidf`
and flashes to a dev board.

**Scope**: `Cargo.toml`, `sdkconfig.defaults`, `.cargo/config.toml`

**Acceptance criteria**:
- `cargo build --release --target xtensa-esp32s3-espidf` succeeds
- `espflash flash` writes firmware to ESP32-S3-DevKitC-1
- Serial monitor shows boot log with PetFilter banner
- Wokwi simulation still works (diagram.json + wokwi.toml)

---

## P0 — Security & Communication (Device Must Talk)

### P0-6: RPC Transport — TLS over TCP

**What**: Implement a `TlsTransport` adapter wrapping a TCP socket with
TLS 1.3 (via ESP-IDF's mbedtls). This is the **only** network-facing
endpoint on the device.

**Scope**: New `adapters/tls_transport.rs` implementing `rpc::Transport`

**Details**:
- Server-side TLS using ESP-IDF's mbedtls integration
- Pre-shared key (PSK) mode for initial pairing, certificate mode post-setup
- No plaintext TCP fallback — TLS is mandatory
- Single listening socket on a fixed port (e.g., 4242)
- Connection limit: 1 concurrent client (embedded constraint)

**Acceptance criteria**:
- `TlsTransport` implements `rpc::transport::Transport` trait
- TLS 1.3 handshake completes with a test client
- All RPC frames transit encrypted
- Connection rejected if TLS handshake fails
- Wireshark confirms no plaintext payload leakage

---

### P0-7: RPC Authentication & Session Hardening

**What**: Add authentication, replay protection, and rate limiting to the
RPC engine.

**Scope**: `rpc/engine.rs`, `rpc/codec.rs`, new `rpc/auth.rs`

**Details**:
- **Pairing flow**: First-time device pairing via BLE provisions a shared
  secret (256-bit PSK). This PSK is stored in encrypted NVS.
- **Session auth**: On TLS connect, client must send an `AuthRequest` with
  HMAC-SHA256 of a server-provided nonce + the PSK. Unauthenticated
  sessions can only call `GetDeviceInfo`.
- **Replay protection**: Monotonic sequence number per session; reject
  out-of-order or replayed message IDs.
- **Rate limiting**: Max 60 RPC calls/minute per session. Burst: 10.
  Excess calls get `AckResponse { success: false, message: "rate limited" }`.

**Schema changes** (`petfilter.fbs`):
```
table AuthChallengeRequest {}
table AuthChallengeResponse { nonce: [ubyte]; }
table AuthVerifyRequest { hmac: [ubyte]; }
table AuthVerifyResponse { success: bool; session_token: [ubyte]; }
```

**Acceptance criteria**:
- Unauthenticated client can only call `GetDeviceInfo`
- Authenticated client has full RPC access
- Replayed message ID rejected with error
- Rate-limited client receives explicit error, not silent drop
- PSK stored in encrypted NVS namespace

---

### P0-8: FlatBuffers Build Integration

**What**: Wire `flatc` compiler into the Cargo build so the FBS schema
generates Rust bindings automatically. Replace manual message dispatch.

**Scope**: `build.rs`, `firmware/schemas/petfilter.fbs`, `rpc/engine.rs`

**Acceptance criteria**:
- `cargo build` invokes `flatc --rust` on `petfilter.fbs`
- Generated Rust code lives in `target/` (not committed)
- `RpcEngine::dispatch_frame` uses generated types, not raw byte offsets
- Schema changes automatically regenerate bindings
- Zero manual `payload[0] = 14;` byte-level serialization remains

---

## P1 — Connectivity & Provisioning (Beta Firmware)

### P1-1: BLE Provisioning — NimBLE GATT Implementation

**What**: Wire the NimBLE stack in `adapters/ble.rs` so a mobile app can
provision WiFi credentials and pair the device.

**Scope**: `adapters/ble.rs` cfg(espidf) blocks

**Flow**:
1. Device boots with no WiFi creds -> enters BLE advertising
2. Mobile app connects, writes SSID + password to GATT characteristics
3. Mobile app writes a 256-bit PSK to a pairing characteristic
4. Device validates inputs (already implemented), stores to encrypted NVS
5. Device attempts WiFi connection, reports status via BLE notify
6. On success: BLE advertising stops, device switches to WiFi+TLS RPC

**Acceptance criteria**:
- NimBLE GATT server advertises service UUID
- SSID/password characteristics writable (with existing validation)
- PSK pairing characteristic writable (32 bytes, stored in encrypted NVS)
- Status characteristic readable + notifiable
- Device transitions from BLE provisioning to WiFi RPC mode

---

### P1-2: WiFi Station Driver — EspWifi Integration

**What**: Wire the ESP-IDF WiFi driver in `adapters/wifi.rs` cfg(espidf)
blocks so the device can join an AP.

**Scope**: `adapters/wifi.rs` — `platform_connect`, `platform_disconnect`,
`platform_is_connected`

**Acceptance criteria**:
- Device connects to a provisioned AP on boot
- Exponential backoff reconnection works on disconnect
- WiFi state transitions visible via BLE status characteristic
- RSSI available for diagnostics
- No AP mode, no HTTP server, no captive portal

---

### P1-3: mDNS Service Advertisement

**What**: Advertise the device on the LAN via mDNS so the companion app
can discover it without manual IP entry.

**Scope**: New code in `adapters/wifi.rs` or dedicated `adapters/mdns.rs`

**Details**:
- Service type: `_petfilter._tcp`
- TXT records: `version=<fw_version>`, `id=<device_id>`
- Hostname: `petfilter-<last4-of-mac>.local`
- No HTTP, no web interface — just service advertisement for RPC discovery

**Acceptance criteria**:
- `dns-sd -B _petfilter._tcp` (or `avahi-browse`) discovers the device
- Companion app resolves hostname to IP for TLS connection
- Advertisement stops during deep sleep, resumes on wake

---

### P1-4: Device ID from MAC Address

**What**: Generate a stable, unique device identifier from the ESP32's
factory-burned MAC address.

**Scope**: New `adapters/device_id.rs` or in `config.rs`

**Details**:
- Read MAC via `esp_efuse_mac_get_default()` or `esp_read_mac()`
- Derive device ID: `PF-<last 6 hex digits of MAC>` (e.g., `PF-A1B2C3`)
- Available in `GetDeviceInfoResponse` and mDNS TXT record
- Used as NVS namespace prefix for multi-device scenarios

**Acceptance criteria**:
- Device ID is deterministic (same across reboots)
- Available via RPC `GetDeviceInfo`
- Appears in mDNS TXT record
- Appears in BLE advertising data (device name)

---

### P1-5: Config Dirty-Flag + Auto-Persist

**What**: Track unsaved configuration changes and auto-persist to NVS
after a configurable idle period.

**Scope**: `adapters/nvs.rs`, `app/service.rs`

**Details**:
- `AppService` tracks a `config_dirty: bool` flag
- When `AppCommand::UpdateConfig` is processed, flag is set
- After 5 seconds of no further config changes, auto-save to NVS
- Explicit `AppCommand::SaveConfig` for immediate persist
- On fault/shutdown, dirty config is force-saved

**Acceptance criteria**:
- Config changes via RPC don't trigger immediate NVS write (reduces wear)
- Config auto-saves after 5s idle
- Config force-saves on shutdown or fault
- Power-cycle preserves last saved config

---

### P1-6: Button Driver — ISR Debounced

**What**: GPIO interrupt-driven button handler with edge detection and
configurable debounce.

**Scope**: New `drivers/button.rs`

**Details**:
- Follows the proven ISR pattern from `sensors/flow.rs`
- Configurable debounce period (default 50ms)
- Edge-triggered (falling edge for normally-open buttons)
- Pushes `Event::ButtonPress` into the SPSC event queue
- Support for short-press and long-press (>2s) detection

**Button actions** (wired in `main.rs`):
- **Short press**: Manual scrub start/stop toggle
- **Long press (5s)**: Factory reset (erase NVS + restart into BLE provisioning)
- **Double press**: Enter/exit boost mode

**Acceptance criteria**:
- Button presses generate events in the ISR queue
- No bouncing — clean single event per press
- Long press detected accurately
- Factory reset clears NVS and restarts into provisioning mode

---

### P1-7: LED Status Patterns — Extended

**What**: Add blink/pulse patterns for connectivity states beyond the
existing solid FSM colors.

**Scope**: `drivers/status_led.rs` or new `drivers/led_patterns.rs`

**Patterns**:
| State | Pattern | Color |
|-------|---------|-------|
| BLE provisioning | Slow pulse (1Hz) | Purple (128,0,255) |
| WiFi connecting | Fast blink (4Hz) | Blue (0,100,255) |
| WiFi connected | Solid brief flash | Green (0,255,100) |
| RPC client connected | Subtle breathing | Teal (0,180,148) |
| Factory reset | Rapid flash (8Hz) | Red (255,0,0) |
| OTA in progress | Chase pattern | Amber (255,180,0) |
| Low water | Double-blink | Yellow (255,200,0) |

**Acceptance criteria**:
- Patterns run via a state machine, not blocking delays
- FSM state colors take priority over connectivity patterns
- Pattern transitions are smooth (no jarring flicker)

---

## P2 — Production Readiness

### P2-1: Secure OTA via RPC

**What**: Firmware updates delivered through the encrypted RPC channel
using ESP-IDF's OTA API with A/B partitioning.

**Scope**: New `rpc/ota.rs`, schema additions, `app/commands.rs`

**Flow**:
1. Client sends `OtaBeginRequest { size: u32, sha256: [u8;32] }`
2. Device validates free space, responds with `AckResponse`
3. Client streams `OtaChunkRequest { offset: u32, data: [u8] }` frames
4. Device writes chunks to inactive OTA partition
5. Client sends `OtaFinalizeRequest`
6. Device verifies SHA-256, marks partition bootable, reboots

**Security**:
- Only authenticated sessions can initiate OTA
- SHA-256 integrity check before committing
- Rollback to previous partition if new firmware fails 3 boots
- Anti-rollback: monotonic version counter in eFuse (optional, P2+)

**Acceptance criteria**:
- Full firmware update over RPC without physical access
- SHA-256 verified before reboot
- Failed update rolls back automatically
- OTA progress reported via telemetry stream

---

### P2-2: Crash Logging to NVS

**What**: Store panic/crash information in NVS for post-mortem diagnostics
via the `GetDiagnostics` RPC method.

**Scope**: New `diagnostics.rs`, NVS namespace `"crash"`

**Details**:
- Custom panic handler writes: timestamp, crash reason, PC, backtrace (truncated)
- Ring buffer of last 4 crashes in NVS (overwrites oldest)
- `AppCommand::GetDiagnostics` retrieves crash log via RPC
- `AppCommand::ClearDiagnostics` erases the log

**Acceptance criteria**:
- Panic info survives reboot
- Retrievable via RPC
- Doesn't corrupt config or credential NVS namespaces
- Bounded storage (max 4 entries x 256 bytes = 1KB)

---

### P2-3: Runtime Metrics & Diagnostics RPC

**What**: Expose runtime health metrics via RPC for the companion app's
diagnostics screen.

**Scope**: Schema additions, `app/service.rs`, new `diagnostics.rs`

**Schema additions**:
```
table GetDiagnosticsRequest {}
table DiagnosticsResponse {
    uptime_secs: ulong;
    total_cycles: uint;
    total_faults: uint;
    crash_count: ubyte;
    free_heap: uint;
    min_free_heap: uint;
    wifi_rssi: short;
    nvs_free_entries: uint;
    ulp_wake_count: uint;
}
```

**Acceptance criteria**:
- `GetDiagnostics` returns all fields populated
- `free_heap` / `min_free_heap` from ESP-IDF heap caps
- `wifi_rssi` from WiFi driver
- Metrics reset on reboot (except crash_count which persists)

---

### P2-4: Watchdog Timer

**What**: Hardware watchdog ensures the system resets if the main loop
hangs (the firmware's last line of defense).

**Scope**: `main.rs`, new code in `safety.rs` or `drivers/watchdog.rs`

**Details**:
- ESP-IDF Task Watchdog Timer (TWDT) on the main task
- Timeout: 10 seconds (control loop runs at 1 Hz, so 10 missed ticks = hung)
- Fed every `ControlTick` in the event loop
- On trigger: logs to NVS crash log, then hardware reset

**Acceptance criteria**:
- Watchdog fires if main loop stalls for >10s
- Crash reason stored in NVS before reset
- Normal operation never triggers the watchdog
- Wokwi simulation disables the watchdog (no TWDT in sim)

---

### P2-5: Flow Sensor ISR Wiring

**What**: Register the existing `flow_isr_handler` as a real GPIO ISR
on the ESP32.

**Scope**: `sensors/flow.rs` cfg(espidf), `main.rs` init

**Details**:
- The ISR handler and atomic counter already exist
- Need: `PinDriver` with rising-edge interrupt on `FLOW_PULSE_GPIO`
- Register via `pin.set_interrupt_type(InterruptType::PosEdge)`
- Subscribe: `pin.enable_interrupt()` + set callback to `flow_isr_handler`

**Acceptance criteria**:
- Flow pulses counted via hardware interrupt (not polling)
- `FlowSensor::read()` returns accurate mL/min
- ISR latency doesn't impact control loop

---

### P2-6: UVC Interlock ISR

**What**: Register a GPIO ISR for the UVC safety interlock (reed switch)
so lid-open events are detected immediately, not on the next poll cycle.

**Scope**: `sensors/mod.rs` or new `drivers/interlock.rs`, `main.rs`

**Details**:
- Rising + falling edge interrupt on `UVC_INTERLOCK_GPIO`
- ISR pushes `Event::InterlockChanged` into SPSC queue
- Safety supervisor evaluates on next tick (already implemented)

**Acceptance criteria**:
- Lid open -> UVC disabled within 1 control tick (~1ms ISR + 1s tick)
- No missed interlock events during deep sleep transitions
- Interlock state included in telemetry

---

### P2-7: Water Level Change ISR

**What**: Register GPIO ISRs for both water level sensors so tank-empty
events are detected immediately.

**Scope**: `sensors/water_level.rs`, `main.rs`

**Details**:
- Falling edge interrupt on `WATER_LEVEL_A_GPIO` and `_B_GPIO`
- ISR pushes `Event::WaterLevelChanged`
- Safety supervisor shuts down pump if Tank A goes low

**Acceptance criteria**:
- Pump stops within 1 control tick of Tank A going empty
- Event logged in telemetry stream
- LED shows low-water pattern

---

### P2-8: GitHub Actions CI Pipeline

**What**: Automated build + test + lint on every push.

**Scope**: `.github/workflows/firmware.yml`

**Jobs**:
1. `cargo fmt --check` — formatting
2. `cargo clippy` — lint (both host and xtensa targets)
3. `cargo test` — run all `#[cfg(test)]` unit tests (host target)
4. `cargo build --release --target xtensa-esp32s3-espidf` — cross-compile
5. Optional: Wokwi CI simulation (headless)

**Acceptance criteria**:
- PR checks block merge on lint/test failure
- Cross-compilation verified on every push
- Badge in README shows build status

---

## Excluded Items (Explicit)

| Legacy Item | Reason Excluded |
|------------|-----------------|
| Web dashboard (HTML/CSS/JS) | No webUI — companion app only |
| Captive portal for WiFi provisioning | No captive portal — BLE provisioning only |
| REST API endpoints | No REST — RPC only |
| MQTT / Home Assistant auto-discovery | No MQTT — federated encrypted RPC only |
| AP-mode WiFi | No AP mode — station mode only |
| CSS dark theme / card layout | No web interface |
| Settings menu with timeout | No physical display — button + LED only |

### Home Assistant Note

HA integration is achievable **without MQTT on the device** by running an
RPC-to-MQTT bridge on the companion app (phone or home server). The device
stays RPC-only; the bridge translates to HA's MQTT discovery protocol.
This keeps the device's attack surface minimal.

---

## Scorecard

| Category | Count | Effort Estimate |
|----------|-------|----------------|
| P0 (Bench Prototype) | 8 tasks | ~2-3 weeks |
| P1 (Beta Firmware) | 7 tasks | ~2-3 weeks |
| P2 (Production) | 8 tasks | ~3-4 weeks |
| **Total** | **23 tasks** | **~7-10 weeks** |

### Critical Path

```
P0-5 (Build) -> P0-1 (HAL) -> P0-4 (Timers) -> P0-2 (NVS)
                                                      |
P0-8 (flatc) -> P0-6 (TLS) -> P0-7 (Auth) -> P1-1 (BLE) -> P1-2 (WiFi) -> P1-3 (mDNS)
```

The build system and HAL wiring gate everything. TLS + Auth gate all
network communication. BLE provisioning gates WiFi, which gates mDNS.

---

## Improvements

- Firmware versioning
  - monotonic version counter in eFuse
  - version stored in NVS
  - version reported in RPC
  - version reported in telemetry
  - version reported in diagnostics
  - version reported in logging
  - version reported in error handling
- CPU Task Pinning, ESP32-S3 has 2 cores, can pin tasks to cores
 - main task to core 0
 - sensor reading task to core 1
 - control task to core 0
 - communication task to core 1
 - safety watchdog to core 0
 - or some variant of this following best practices and FreeRTOS best practices
- Asynchronous communication (RPC over TCP/BLE)
  - async-tcp
  - async-rpc
  - async-ble
  - chunked transfer encoding
  - compression
  - encryption
  - authentication
  - rate limiting
  - replay protection
  - session management
  - telemetry
  - diagnostics
  - logging
  - error handling
- Asynchronous OTA
  - A/B partitioning
  - SHA-256 verification
  - rollback protection
  - progress reporting
  - error handling
- Multiple RPC Clients simultaneously
  - each client has its own session
- X.509 certificates
- TLS Certificate Auth beyond PSK